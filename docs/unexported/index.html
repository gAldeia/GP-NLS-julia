<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Auxiliary functions (unexported) · GP_NLS</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GP_NLS</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">GP_NLS in Julia</a></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../exported/datatypes/">Data Types</a></li><li><a class="tocitem" href="../exported/defaultsets/">Default sets</a></li><li><a class="tocitem" href="../exported/auxiliaryfunctions/">Auxiliary Functions</a></li><li><a class="tocitem" href="../exported/gp/">Genetic Programming algorithm</a></li></ul></li><li class="is-active"><a class="tocitem" href>Auxiliary functions (unexported)</a><ul class="internal"><li><a class="tocitem" href="#Tree-structural-nodes"><span>Tree structural nodes</span></a></li><li><a class="tocitem" href="#Auxiliary-functions"><span>Auxiliary functions</span></a></li><li><a class="tocitem" href="#Tree-Evaluation"><span>Tree Evaluation</span></a></li><li><a class="tocitem" href="#Population-Initialization"><span>Population Initialization</span></a></li><li><a class="tocitem" href="#Non-linear-Least-Squares-optimization"><span>Non-linear Least Squares optimization</span></a></li><li><a class="tocitem" href="#Genetic-Programming-algorithm"><span>Genetic Programming algorithm</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Auxiliary functions (unexported)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Auxiliary functions (unexported)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gAldeia/GP-NLS-julia" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Unexported-functions"><a class="docs-heading-anchor" href="#Unexported-functions">Unexported functions</a><a id="Unexported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Unexported-functions" title="Permalink"></a></h1><p>The module has some built-in auxiliary functions that its external use is not recommended. All implementations are listed in the modules of the library, but only some functions are exported outside the package.</p><h2 id="Tree-structural-nodes"><a class="docs-heading-anchor" href="#Tree-structural-nodes">Tree structural nodes</a><a id="Tree-structural-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-structural-nodes" title="Permalink"></a></h2><p>To build the expression trees, the defined <em>structs</em> are used. Those serves as the backbone of the tree, where every node has a different content.</p><h3 id="Types-and-functions"><a class="docs-heading-anchor" href="#Types-and-functions">Types and functions</a><a id="Types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.AbstractNode" href="#GP_NLS.AbstractNode"><code>GP_NLS.AbstractNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type of our symbolic tree nodes. The idea of creating this type is to create subtypes <code>InternalNode</code> and <code>TerminalNode</code>, and then use multiple dispatch to implement functions that should have different behavior when manipulating the expression trees.</p><p>Expression trees should not be built using <code>Var, WeightedVar, Const, Func, ERC</code>, but with these nodes, which  are intended to be used as the &quot;backbone&quot; of the tree. The backbone is build using the <code>InternalNode</code> and <code>TerminalNode</code>, and its contents should be the ones declared in <span>$NodeContent.jl$</span>.</p><p>A terminal node must have as its contents only the types <code>Const, Var, WeightedVar</code>, and an internal nodemust have its contents the type <code>Func</code>.</p><p>Notice that the ERC, when selected to be used in a terminal during the creation of a tree, is replaced by a random Const node). There are not any explicit ERC terminal in the trees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.InternalNode" href="#GP_NLS.InternalNode"><code>GP_NLS.InternalNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p><em>Struct</em> to build the internal nodes of the backbone of the tree. Its contents will always be of the <code>func</code> type, a <code>f ::Func</code> function that will necessarily have <code>f.arity</code> children, where <code>f.arity</code> is the arity of the function.</p><pre><code class="language-none">InternalNode(f::Func, children::Vector{AbstractNode}) &lt;: AbstractNode</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.TerminalNode" href="#GP_NLS.TerminalNode"><code>GP_NLS.TerminalNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p><em>Struct</em> to build the terminal nodes of the backbone of the tree. Its contents will always be of the <code>terminal</code> type: <code>Union{Const, Var, WeightedVar}</code>.</p><pre><code class="language-none">TerminalNode(terminal::Union{Const, Var, WeightedVar}) &lt;: AbstractNode</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><h2 id="Auxiliary-functions"><a class="docs-heading-anchor" href="#Auxiliary-functions">Auxiliary functions</a><a id="Auxiliary-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Auxiliary-functions" title="Permalink"></a></h2><p>Implementation of some auxiliary functions that are used to inspect and manipulate trees more generally.</p><h3 id="Types-and-functions-2"><a class="docs-heading-anchor" href="#Types-and-functions-2">Types and functions</a><a class="docs-heading-anchor-permalink" href="#Types-and-functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.branches_in_limits" href="#GP_NLS.branches_in_limits"><code>GP_NLS.branches_in_limits</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Finds all branches of any tree <code>node</code> that have a number of nodes less than or equal to <code>allowedSize</code> <strong>and</strong> a depth less than or equal to <code>allowedDepth</code> . Returns a list with the position of all branches found.</p><pre><code class="language-none">branches_in_limits(
    allowedSize::Int64, allowedDepth::Int64, node::AbstractNode, _point::Int64=1)::Vector{Int64}</code></pre><p>The <code>_point</code> parameter being returned is for internal use, and serves to monitor the point of the tree where the candidates were found. This is only meaningful to recursive calls, and outside of the function it does not represent any useful information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}" href="#GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}"><code>GP_NLS.change_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Takes a point <code>p</code> of type integer (<strong>which must be less than or equal to the number of nodes of <code>branch</code></strong>), a branch of type <code>AbstractNode</code>, and any node <code>AbstractNode</code> representing a tree. Returns a modification of the tree by inserting the branch into the tree at position `<span>$p$</span>. <strong>This function changes the tree passed as argument</strong>.</p><pre><code class="language-none">change_at!(p::Int64, branch::AbstractNode, node::AbstractNode)::AbstractNode</code></pre><p>This method is mainly used to modify trees in the <em>crossover</em> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}" href="#GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}"><code>GP_NLS.change_children!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes a point <code>p</code> (<strong>which must be less than or equal to the number of nodes of <code>branch</code></strong>), a branch of type <code>AbstractNode</code>, and a list of children <code>Vector{AbstractNode}</code>. Returns a modification of the list of children, where the <code>p</code> position node will be replaced by the given branch. <strong>This function changes the list of children passed as argument</strong>.</p><pre><code class="language-none">change_children!(p::Int64, branch::AbstractNode, children::Vector{AbstractNode})::Vector{AbstractNode}</code></pre><p>This function is a helper to <code>change_at!</code>, and itsfor internal use. It is not exported by the module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}" href="#GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.copy_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and recursively recreates the structure so that references are not shared between the tree passed and the tree returned, avoiding side effects when manipulating the tree.</p><pre><code class="language-none">copy_tree(node::AbstractNode)::TerminalNode</code></pre><p>This function works by having a multiple dispatch for each subtype of <code>AbstractNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}" href="#GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}"><code>GP_NLS.get_branch_at</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and an integer <code>p</code> (<strong>which must be less than or equal to the number of nodes in <code>tree</code></strong>) and returns the branch at position <code>p</code>.</p><pre><code class="language-none">get_branch_at(p::Int64, node::AbstractNode)::AbstractNode</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}" href="#GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}"><code>GP_NLS.get_depth_at</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Takes a point <code>p</code> of type integer (<strong>which must be less than or equal to the number of nodes of the <code>node</code> passed</strong>) and any node <code>AbstractNode</code> representing a tree, then this function find and return the depth of the subtree at position <code>p</code>.</p><pre><code class="language-none">get_depth_at(p::Int64, node::AbstractNode)::Int64</code></pre><p>It&#39;s almost like finding the depth of the tree, but when we are interested  in finding the depth of a subtree that is at the point <code>p</code>, not the whole tree depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}" href="#GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}"><code>GP_NLS.which_children</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes a set of children of the same node as the array <code>children::Vector{AbstractNode}</code>, and an integer <code>p</code> (<strong>which must be less than or equal to number of nodes in <code>children</code></strong>) and finds the child containing the p-th node of the children if it was traversed inorder.</p><p>Returns a tuple containing the child which contains the node of index <code>p</code>, and an integer informing the position of the p-th node within the returned (child) subtree.</p><pre><code class="language-none">which_children(p::Int64, children::Vector{AbstractNode})::Tuple{Int64, AbstractNode}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><h2 id="Tree-Evaluation"><a class="docs-heading-anchor" href="#Tree-Evaluation">Tree Evaluation</a><a id="Tree-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Evaluation" title="Permalink"></a></h2><p>Functions that evaluate a tree for a given dataset and calculates its fitness.</p><h3 id="Types-and-functions-3"><a class="docs-heading-anchor" href="#Types-and-functions-3">Types and functions</a><a class="docs-heading-anchor-permalink" href="#Types-and-functions-3" title="Permalink"></a></h3><h2 id="Population-Initialization"><a class="docs-heading-anchor" href="#Population-Initialization">Population Initialization</a><a id="Population-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Population-Initialization" title="Permalink"></a></h2><p>Implementation of different functions to initialize individual trees, as well  as functions to create an entire population.</p><h3 id="Types-and-functions-4"><a class="docs-heading-anchor" href="#Types-and-functions-4">Types and functions</a><a class="docs-heading-anchor-permalink" href="#Types-and-functions-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64}" href="#GP_NLS.PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64}"><code>GP_NLS.PTC2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tree creation with the Probabilistic Tree Creator 2 (PTC2) method, described in <strong>Two Fast Tree-Creation Algorithms for Genetic Programming</strong>, by Sean Luke.</p><p>This method looks like Koza&#39;s <em>full</em> method, but in addition to respecting a limit of <code>maxDepth</code> depth, it also respects a limit of number of nodes  <code>expctdSize</code>.</p><p>PTC2 ensures that the depth does not exceed the maximum (in our case, weighted variables count as depth 1), and ensures that the number of nodes does not exceed the expected value added to the highest arity between the functions, that is, <span>$expctdSize + max(arity(f)), f in fSet$</span>.</p><pre><code class="language-none">PTC2(
    fSet::Vector{Func},
    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},
    maxDepth::Int64,
    expctdSize::Int64)::AbstractNode</code></pre><p>Here we adopt that the chance to select a <span>$t$</span> terminal will be uniform for all possible terminals, and the chance to select a function will also follow the same logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS._create_random_terminal-Tuple{Array{Union{ERC, Const, Var, WeightedVar},1}}" href="#GP_NLS._create_random_terminal-Tuple{Array{Union{ERC, Const, Var, WeightedVar},1}}"><code>GP_NLS._create_random_terminal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that receives the set of terminal contents and creates a random terminal node.</p><pre><code class="language-none">_create_random_terminal(
    tSet::Vector{Union{Var, WeightedVar, Const, ERC}})::TerminalNode</code></pre><p>Creating a terminal node involves an additional verification step for the case of ERC, which must be replaced with a constant within the range specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}" href="#GP_NLS.full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}"><code>GP_NLS.full</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that creates a tree using the <em>full</em> method, inspired by Koza&#39;s original work. Receives a set of <code>fSet::Vector{Func}</code> functions, a set of <code>tSet::Vector{Union{Var, WeightedVar, Const, ERC}}</code> terminals, and a maximum depth of <code>maxDepth::Int64</code> allowed.</p><p>Returns any tree with maximum depth <code>maxDepth</code> and using the contents of past functions and terminals.</p><pre><code class="language-none">full(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}},
        maxDepth::Int64)::AbstractNode</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}" href="#GP_NLS.grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}"><code>GP_NLS.grow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that creates a tree using the <em>grow</em> method, inspired by Koza&#39;s original work. Receives a set of <code>fSet::Vector{Func}</code> functions that will be used in the internal nodes, a set of <code>tSet::Vector{Union{Var, WeightedVar, Const, ERC}}</code> terminals, and a maximum depth of <code>maxDepth::Int64</code> allowed.</p><p>Returns any tree with maximum depth <code>maxDepth</code> created using the functions and terminal sets.</p><pre><code class="language-none"> grow(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}},
        maxDepth::Int64)::AbstractNode</code></pre><p>Note that there is no minimum size, meaning that a single-node tree can be returned. The maximum depth considers weighted variables as a single node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.init_pop_PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}" href="#GP_NLS.init_pop_PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}"><code>GP_NLS.init_pop_PTC2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that initializes a population of size <code>popSize</code> using the <em>PTC2</em> method.</p><pre><code class="language-none">init_pop_PTC2(
    fSet::Vector{Func}, 
    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, 
    minDepth::Int64,
    maxDepth::Int64,
    expctdSize::Int64,
    popSize::Int64)::Vector{AbstractNode}</code></pre><p>Every initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.init_pop_full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}" href="#GP_NLS.init_pop_full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}"><code>GP_NLS.init_pop_full</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that initializes a population of size <code>popSize</code> using the <em>full</em> method.</p><pre><code class="language-none">init_pop_full(
    fSet::Vector{Func}, 
    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, 
    minDepth::Int64,
    maxDepth::Int64,
    expctdSize::Int64,
    popSize::Int64)::Vector{AbstractNode}</code></pre><p>Every initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.init_pop_grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}" href="#GP_NLS.init_pop_grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}"><code>GP_NLS.init_pop_grow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that initializes a population of size <code>popSize</code> using the <em>grow</em> method.</p><pre><code class="language-none">init_pop_grow(
    fSet::Vector{Func}, 
    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, 
    minDepth::Int64,
    maxDepth::Int64,
    expctdSize::Int64,
    popSize::Int64)::Vector{AbstractNode}</code></pre><p>Every initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.init_pop_ramped-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}" href="#GP_NLS.init_pop_ramped-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}"><code>GP_NLS.init_pop_ramped</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that initializes a population of size <code>popSize</code> using the <em>ramped half-half</em> method.</p><pre><code class="language-none">init_pop_ramped(
    fSet::Vector{Func}, 
    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, 
    minDepth::Int64,
    maxDepth::Int64,
    expctdSize::Int64,
    popSize::Int64)</code></pre><p>Every initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><h2 id="Non-linear-Least-Squares-optimization"><a class="docs-heading-anchor" href="#Non-linear-Least-Squares-optimization">Non-linear Least Squares optimization</a><a id="Non-linear-Least-Squares-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Non-linear-Least-Squares-optimization" title="Permalink"></a></h2><p>Implementation of auxiliary functions and the nonlinear optimization method of coefficients. All functions declared here are for internal use by the module.</p><h3 id="Types-and-functions-5"><a class="docs-heading-anchor" href="#Types-and-functions-5">Types and functions</a><a class="docs-heading-anchor-permalink" href="#Types-and-functions-5" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.adaptate_tree-Tuple{GP_NLS.AbstractNode}" href="#GP_NLS.adaptate_tree-Tuple{GP_NLS.AbstractNode}"><code>GP_NLS.adaptate_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that receives a tree and makes the necessary adaptations to be able to apply the optimization with the nonlinear least squares method. Does not modify the arguments. Returns a function that receives <code>X</code> and <code>theta</code> to perform tree evaluation, the initial <code>theta</code> vector (which corresponds to the original coefficients of the tree before the optimization process), and the adapted tree.</p><pre><code class="language-none">adaptate_tree(node::AbstractNode)::Tuple{Function, Vector{Float64}, AbstractNode}</code></pre><p>The adaptation is done by adding 4 new nodes in the tree, to create the linear transformation box (it adds an intercept and a slope to the tree). This function The returned function takes as arguments <code>X::Matrix{Float64}</code> and <code>theta::Vector{Float64}</code> to perform the evaluation (<code>evaluate</code>). The <code>H</code> function returned is internally used in an autodiff algorithm to obtain the Jacobian in the optimization method.</p><p>This function is for the internal use of the package, and is used in the     optimization method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.apply_local_opt" href="#GP_NLS.apply_local_opt"><code>GP_NLS.apply_local_opt</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Function that receives a node of a tree (<code>AbstractNode</code>), an array with the <code>X::Matrix{Float64}</code> training data, and an array with expected values <code>y::Vector{Float64}</code>, and applies the optimization process of non-linear least squares. Returns an adjusted tree.</p><pre><code class="language-none">apply_local_opt(
    node::AbstractNode, X::Matrix{Float64},
    y::Vector{Float64}, keep_linear_transf_box=false)::AbstractNode</code></pre><p>We can choose to return the expression with/without the transformation box. In case it is returned, it is worth noting that the code will not apply mutation or crossover at the nodes of the block.</p><p>This function is for the internal use of the package, and is used in the     optimization method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.evaluate_replacing_consts" href="#GP_NLS.evaluate_replacing_consts"><code>GP_NLS.evaluate_replacing_consts</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Function that evaluates the tree simulating that the constants were replaced by the <code>theta</code> values. The idea is to simulate the replacement without the need of completely rebuild the tree, aiming to reduce the computational cost when the optimization method performs many iterations.</p><pre><code class="language-none">evaluate_replacing_consts(
    node::Union{TerminalNode, InternalNode}, X::Matrix{Float64},
    theta::Vector{Float64}, c_idx::Int64=0)::Tuple{Vector{Float64}, Int64}</code></pre><p>The <code>c_idx</code> variable is used internally to keep track of the indexes of <code>theta</code> that have already been used or not, so that the replacement simulation is done correctly.</p><p>This function is for the internal use of the package, and is used in the optimization method. Implements multiple dispatch.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.find_const_nodes" href="#GP_NLS.find_const_nodes"><code>GP_NLS.find_const_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Function that takes a node of a tree (<code>AbstractNode</code>) and traverses it recursively, looking for all terminal nodes that have as content a <code>Const</code> or a <code>WeightedVar</code>. This function makes internal use of a list of nodes <code>Vector{AbstractNode}</code>, which is passed by reference to the calls recursively. The recursive calls will add a reference to the nodes found in this list.</p><pre><code class="language-none">find_const_nodes(
    node::AbstractNode, nodes=Vector{AbstractNode}())::Vector{TerminalNode}</code></pre><p>This function is for the internal use of the package, and is used in the optimization method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.replace_const_nodes" href="#GP_NLS.replace_const_nodes"><code>GP_NLS.replace_const_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Function that takes a node of a tree (<code>AbstractNode</code>) and a vector of type <code>theta::Vector{Float64}</code> with the same number of elements as the number of constants from the given tree, and recursively replaces the constants of the tree. This is the update step of the GP-NLS algorithm, where we take new vales for the constants and replace them in the original tree with the elements of <code>theta</code>. This function does not change the arguments passed, and returns a new tree.</p><p>The <code>theta</code> must have the same number of the total count of <code>Const</code> and <code>WeightedVar</code> nodes in the tree.</p><pre><code class="language-none">replace_const_nodes(
    node::AbstractNode, theta::Vector{Float64}, _first_of_stack=true)::AbstractNode</code></pre><p>The <code>_first_of_stack</code> argument is for internal use of the function. It is used to create a copy of <code>theta</code> where is safe to remove elements without changing the original vector.</p><p>This function is for the internal use of the package, and is used in the optimization method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><h2 id="Genetic-Programming-algorithm"><a class="docs-heading-anchor" href="#Genetic-Programming-algorithm">Genetic Programming algorithm</a><a id="Genetic-Programming-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Genetic-Programming-algorithm" title="Permalink"></a></h2><p>Mutation, crossover and GP implementation.</p><h3 id="Types-and-functions-6"><a class="docs-heading-anchor" href="#Types-and-functions-6">Types and functions</a><a class="docs-heading-anchor-permalink" href="#Types-and-functions-6" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.crossover-Tuple{GP_NLS.AbstractNode,GP_NLS.AbstractNode,Int64,Int64}" href="#GP_NLS.crossover-Tuple{GP_NLS.AbstractNode,GP_NLS.AbstractNode,Int64,Int64}"><code>GP_NLS.crossover</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Crossover function that does a recombination of the two parents passed as an argument, finding a breakpoint in each of the parent trees and swapping the subtree between those breakpoints. It doesn&#39;t change the parents. This crossover controls the number of nodes (not the depth) of the tree, avoiding to  exceed the maximum value.</p><pre><code class="language-none">crossover(
    fst_parent::AbstractNode,
    snd_parent::AbstractNode,
    maxDepth::Int64,
    maxSize::Int64)::AbstractNode</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.mutation!-Tuple{GP_NLS.AbstractNode,Int64,Int64,Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Float64}" href="#GP_NLS.mutation!-Tuple{GP_NLS.AbstractNode,Int64,Int64,Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Float64}"><code>GP_NLS.mutation!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that implements a traditional substitution mutation in a tree, respecting the maximum past depth. <strong>Modifies the tree passed</strong>.</p><pre><code class="language-none">mutation!(
    node::AbstractNode,
    maxDepth::Int64,
    maxSize::Int64,
    fSet::Vector{Func},
    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},
    mutationRate::Float64)::AbstractNode</code></pre><p>The <code>mutationRate</code> mutation rate should vary by <span>$[0, 1]$</span> and determines the chance of occurring a mutation (replacing a random point with a new subtree). If no mutation is performed, then the given node is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.tourn_selection-Tuple{Tuple{GP_NLS.AbstractNode,Float64},Tuple{GP_NLS.AbstractNode,Float64}}" href="#GP_NLS.tourn_selection-Tuple{Tuple{GP_NLS.AbstractNode,Float64},Tuple{GP_NLS.AbstractNode,Float64}}"><code>GP_NLS.tourn_selection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that receives two individuals and makes a simple tournament selection. An individual is a <code>(fitness::Float64, node::AbstractNode)</code> tuple with the tree and it fitness, to avoid recalculations all the time.</p><pre><code class="language-none">tourn_selection(
    ind1::Tuple{Float64, AbstractNode},
    ind2::Tuple{Float64, AbstractNode})::Tuple{AbstractNode, Float64}</code></pre><p>The return type is a tuple with the winning individual(that is, the  individual winner tuple is returned).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../exported/gp/">« Genetic Programming algorithm</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 18 November 2021 15:47">Thursday 18 November 2021</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
