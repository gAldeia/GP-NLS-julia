var documenterSearchIndex = {"docs":
[{"location":"exported/gp/#Tree-Evaluation","page":"Genetic Programming algorithm","title":"Tree Evaluation","text":"","category":"section"},{"location":"exported/gp/","page":"Genetic Programming algorithm","title":"Genetic Programming algorithm","text":"Functions that evaluate a tree for a given dataset and calculates its fitness.","category":"page"},{"location":"exported/gp/#Functions","page":"Genetic Programming algorithm","title":"Functions","text":"","category":"section"},{"location":"exported/gp/","page":"Genetic Programming algorithm","title":"Genetic Programming algorithm","text":"Modules = [GP_NLS]\r\nPrivate = false\r\nPages   = [\"Evaluation.jl\"]","category":"page"},{"location":"exported/gp/#GP_NLS.evaluate-Tuple{GP_NLS.TerminalNode,Array{Float64,2}}","page":"Genetic Programming algorithm","title":"GP_NLS.evaluate","text":"Function that takes any node of a tree (AbstractNode), and an data matrix X (where each row is an observation and each column is a variable), and evaluate the prediction for each observation in X. The function makes a recursive call along the tree node and evaluates the expression using the matrix variable columns that exist in the tree.\n\nIf the node is a InternalNode, the recursive call is made with its children and the result is used as arguments of the node function.\n\nIf it is a TerminalNode with content Const, a vector with size(X, 1) repeatedly containing the constant is returned.\n\nIf it is a TerminalNode with content Var or WeightedVar, the column of the index Var.var_idx of X will be used to extract  the value of the variable from the matrix.\n\nevaluate(node::Union{TerminalNode, InternalNode}, X::Matrix{Float64})::Vector{Float64}\n\nImplements a multiple dispatch for the case of TerminalNode and InternalNode.\n\n\n\n\n\n","category":"method"},{"location":"exported/gp/#GP_NLS.fitness-Tuple{GP_NLS.AbstractNode,Array{Float64,2},Array{Float64,1}}","page":"Genetic Programming algorithm","title":"GP_NLS.fitness","text":"Function that measures the fitness of a given tree, in relation to an training data matrix X::Matrix{Float64} and a vector of expected results y::Vector{Float64}.\n\nfitness(tree::AbstractNode, X::Matrix{Float64}, y::Vector{Float64})::Float64\n\nThe fitness is calculated using the RMSE, and this method returns an infinite fitness if the tree fails to evaluate –- forcing the selective pressure to likely eliminate the individual from the population without having to think about protected operations.\n\n\n\n\n\n","category":"method"},{"location":"exported/gp/#Genetic-Programming-algorithm","page":"Genetic Programming algorithm","title":"Genetic Programming algorithm","text":"","category":"section"},{"location":"exported/gp/","page":"Genetic Programming algorithm","title":"Genetic Programming algorithm","text":"Mutation, crossover and GP implementation.","category":"page"},{"location":"exported/gp/#Functions-2","page":"Genetic Programming algorithm","title":"Functions","text":"","category":"section"},{"location":"exported/gp/","page":"Genetic Programming algorithm","title":"Genetic Programming algorithm","text":"Modules = [GP_NLS]\r\nPrivate = false\r\nPages   = [\"Evolutionary.jl\"]","category":"page"},{"location":"exported/gp/#GP_NLS.GP-Tuple{Array{Float64,2},Array{Float64,1},Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1}}","page":"Genetic Programming algorithm","title":"GP_NLS.GP","text":"GP With depth and number of nodes control. The recommended startup is PTC2, but we have the others as well (however, the other methods are based in the koza GP and do not follow restrictions on the maximum number of nodes). To use canonic GP, just disable lm_optimization and choose one of  [\"ramped\", \"grow\", \"full\"] initializations. To use GP-NLS, turn on  lm_optimization and use \"PTC2\" as initialization method.\n\nGP(\n    X::Matrix{Float64}, \n    y::Vector{Float64},\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    minDepth::Int64        = 1,\n    maxDepth::Int64        = 5,\n    maxSize::Int64         = 25,\n    popSize::Int64         = 50,\n    gens::Int64            = 50,\n    mutationRate::Float64  = 0.25,\n    elitism::Bool          = false,\n    verbose::Bool          = false,\n    init_method::String    = \"PTC2\", #[\"ramped\", \"grow\", \"full\", \"PTC2\"]\n    lm_optimization        = false, \n    keep_linear_transf_box = false\n)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"exported/auxiliaryfunctions/#Auxiliary-functions","page":"Auxiliary Functions","title":"Auxiliary functions","text":"","category":"section"},{"location":"exported/auxiliaryfunctions/","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"Implementation of some auxiliary functions that are used to inspect and manipulate trees more generally.","category":"page"},{"location":"exported/auxiliaryfunctions/#Functions","page":"Auxiliary Functions","title":"Functions","text":"","category":"section"},{"location":"exported/auxiliaryfunctions/","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"Modules = [GP_NLS]\r\nPrivate = false\r\nPages   = [\"Utils.jl\"]","category":"page"},{"location":"exported/auxiliaryfunctions/#GP_NLS.depth-Tuple{GP_NLS.TerminalNode}","page":"Auxiliary Functions","title":"GP_NLS.depth","text":"Function that takes any node of a tree (AbstractNode) and recursively finds the depth of the tree, where the depth is the size of its largest branch. This depth function does not take into count the coefficients of weighted variables (which are, in fact, a subtree with depth 2). To find the depth of a tree considering weighted variables as a subtree (and not as a single node), use the function true_depth.\n\ndepth(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"exported/auxiliaryfunctions/#GP_NLS.getstring-Tuple{GP_NLS.TerminalNode}","page":"Auxiliary Functions","title":"GP_NLS.getstring","text":"Function that takes any node of a tree (AbstractNode) and recursively builds a string representation of the tree, where functions are always denoted in prefixed notation, with arguments in parentheses.\n\ngetstring(node::AbstractNode)::String\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"exported/auxiliaryfunctions/#GP_NLS.numberofnodes-Tuple{GP_NLS.TerminalNode}","page":"Auxiliary Functions","title":"GP_NLS.numberofnodes","text":"Function that takes any node of a tree (AbstractNode) and recursively counts the total number of nodes of the tree. This function counts weighted variables as a single node. To find the number of nodes of a tree considering weighted variables as a subtree (and not as a single node), use the function true_numberofnodes.\n\nnumberofnodes(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"exported/auxiliaryfunctions/#GP_NLS.true_depth-Tuple{GP_NLS.TerminalNode}","page":"Auxiliary Functions","title":"GP_NLS.true_depth","text":"Function that takes any node of a tree (AbstractNode) and recursively finds the depth of the tree, where the depth is the size of its largest branch. This depth function returns a value that corresponds to the number of existing nodes in the tree, considering weighted variables as being a subtree of depth 2. This function is not used in implementations, and is available to users who want to get the real depth of GP-NLS trees.\n\ntrue_depth(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"exported/auxiliaryfunctions/#GP_NLS.true_numberofnodes-Tuple{GP_NLS.TerminalNode}","page":"Auxiliary Functions","title":"GP_NLS.true_numberofnodes","text":"Function that takes any node of a tree (AbstractNode) and recursively counts the total number of nodes of the tree. This function counts weighted  variables as three nodes. This function is only used in mutate, crossover, and initialize operations to avoid creating trees larger than the allowed.\n\ntrue_numberofnodes(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"exported/defaultsets/#Default-sets","page":"Default sets","title":"Default sets","text":"","category":"section"},{"location":"exported/defaultsets/","page":"Default sets","title":"Default sets","text":"There are some default sets available if the user does not want to understand how to create new constants and functions.","category":"page"},{"location":"exported/defaultsets/#Const-sets","page":"Default sets","title":"Const sets","text":"","category":"section"},{"location":"exported/defaultsets/","page":"Default sets","title":"Default sets","text":"Modules = [GP_NLS]\r\nPrivate = false\r\nFilter  = t -> typeof(t) !== DataType\r\nPages   = [\"NodeContent.jl\"]","category":"page"},{"location":"exported/defaultsets/#GP_NLS.defaultConstSet","page":"Default sets","title":"GP_NLS.defaultConstSet","text":"Default const set\n\nConst(3.1415),\nConst(1.0),\nConst(-1.0)\n\n\n\n\n\n","category":"constant"},{"location":"exported/defaultsets/#GP_NLS.defaultERCSet","page":"Default sets","title":"GP_NLS.defaultERCSet","text":"Default ERC set\n\nERC(-1.0, 1.0)\n\n\n\n\n\n","category":"constant"},{"location":"exported/defaultsets/#GP_NLS.defaultFunctionSet","page":"Default sets","title":"GP_NLS.defaultFunctionSet","text":"Default functions set\n\nFunc(+, 2),\nFunc(-, 2),\nFunc(prod, 2),\nFunc(div, 2),\n\nFunc(square, 1),\nFunc(sqrt, 1),\nFunc(exp, 1),\nFunc(log, 1)\n\n\n\n\n\n","category":"constant"},{"location":"exported/datatypes/#Node-contents","page":"Data Types","title":"Node contents","text":"","category":"section"},{"location":"exported/datatypes/","page":"Data Types","title":"Data Types","text":"All representation by trees starts here. These Structs are used as content of the nodes of the tree (and not as direct nodes).","category":"page"},{"location":"exported/datatypes/#Types","page":"Data Types","title":"Types","text":"","category":"section"},{"location":"exported/datatypes/","page":"Data Types","title":"Data Types","text":"Modules = [GP_NLS]\r\nPrivate = false\r\nFilter  = t -> typeof(t) === DataType\r\nPages   = [\"NodeContent.jl\"]","category":"page"},{"location":"exported/datatypes/#GP_NLS.Const","page":"Data Types","title":"GP_NLS.Const","text":"Struct to be the content of an terminal node of an expression tree. This struct represents a Float64 constant value.\n\nConst(v::Float64)\n\nReceives a Float64 value v which will be used as a constant.\n\nThe representation of the constant as string is obtained by rounding the value to 3 decimal places, and it is automatically obtained.\n\nWhen using non-linear optimization, the nonlinear least squares optimization method looks for this struct specifically to optimize their values.\n\n\n\n\n\n","category":"type"},{"location":"exported/datatypes/#GP_NLS.ERC","page":"Data Types","title":"GP_NLS.ERC","text":"Struct to be the content of an terminal node of an expression tree. This struct keeps the range limits for creating a random constant with the ERC method.\n\nERC(lb::Float64, ub::Float64)\n\nThis struct is used to create constants in the terminal nodes. When it is selected to be a terminal, a new terminal will be created with the struct Const with a random value drawn between [lb, ub) to take the place of the ERC (Ephemeral Random Constant) at the terminal node. The string representation of the created constant is as described in Const documentation.\n\n\n\n\n\n","category":"type"},{"location":"exported/datatypes/#GP_NLS.Func","page":"Data Types","title":"GP_NLS.Func","text":"Struct to be the content of an internal node of an expression tree.\n\nFunc(f::Function, a::Int64)\n\nTakes a function f and the arity a of the function. The function must always work in vectorized form (will always receive a arrays with n values, where each value of the array is an observation). So the function input will have a rows and n columns when this node is being evaluated in other methods.\n\nThe function's representation as a string is inferred from the name of the function passed, and when this node is used to create a node of a tree, it will have a children.\n\nWhen creating new functions, protected operators must not be used. The  non-linear optimization method uses autodiff to differentiate the tree, and complex functions can be problematic to automatically differentiate.\n\n\n\n\n\n","category":"type"},{"location":"exported/datatypes/#GP_NLS.Var","page":"Data Types","title":"GP_NLS.Var","text":"Struct to be the content of a terminal node of an expression tree. This struct represents a variable of the data set.\n\nVar(v::String, i::Int64)\n\nReceives a string v that will be used as the representation of the variable when printing the expression (you can use a placeholder if the database do not have column names) and a ì index that matches the column index of the corresponding variable in the observations.\n\n\n\n\n\n","category":"type"},{"location":"exported/datatypes/#GP_NLS.WeightedVar","page":"Data Types","title":"GP_NLS.WeightedVar","text":"Struct to be the content of a terminal node of an expression tree. This struct represents a weighted variable, that have a coefficient associated with it at the time of creation.\n\nWeightedVar(v::String, i::Int64)\n\nThis struct represents a weighted variable, that can be adjusted with  the non-linear least squares method.\n\nThe String representation is inferred as the same way when creating a Var and the coefficient is inferred in the same way as a Const.\n\nWeightedVar(v::String, i::Int64, w::Float64)\n\nAdditionally, you can force a specific coefficient by passing the value as the third argument on the constructor. When no value is specified, the coefficient is set to 1.0.\n\nThis weighted variable is a subtree with 3 nodes and depth 2, but in practice it is treated as a single node, as it is not of interest to make the dissociation between the weight and the variable during the GP process. By treating the weighted variable as a single node, it is not necessary to modify the crossover or mutation implementations to prevent changing the subtree.\n\n\n\n\n\n","category":"type"},{"location":"#GP_NLS-in-Julia-Documentation","page":"GP_NLS in Julia","title":"GP_NLS in Julia Documentation","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"Julia implementation of the GP-NLS algorithm for symbolic regression described in the paper:","category":"page"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"Kommenda, M., Burlacu, B., Kronberger, G. et al. Parameter identification for symbolic regression using nonlinear least squares. Genet Program Evolvable Mach 21, 471–501 (2020).","category":"page"},{"location":"#What-is-Symbolic-Regression?","page":"GP_NLS in Julia","title":"What is Symbolic Regression?","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"Symbolic regression is the task of finding a good mathematical expression to describe the relationship between a set of independent variablesmathbfX = X_1 X_2 ldots X_n with a dependent variableY, normally represented as tabular data:","category":"page"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"In other words, suppose that you have availablem observations withn variables, and a response variable that you supose that have a relationshipf(mathbfX) = Y, but the functionf is unknown: we can only see how the response changes when the input changes, but we don't know how the response is described by the variables of the problem. Symbolic regression tries to find a functionwidehatf that approximates the output of the unknown function just by learning mathematical structures from the data itself.","category":"page"},{"location":"#How-GP-NLS-works","page":"GP_NLS in Julia","title":"How GP-NLS works","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"The idea behind the use of evolutionary algorithms is to manipulate a population of mathematical expressions computationally (represented using expression trees). A fitness function, which measures how good each expression is (this function could be, for example, the Mean Squared Error) the individuals of the population have their fitness to represent how well each function describes the data. Through variation operations (which define the power of exploration of the algorithm, done in the full search space, or the power of exploration, which performs a local search) and selective pressure (which promote the maintenance of good solutions in the population), a simulation of the evolutionary process tends to converge to good solutions present in the population. However, it is worth noting that there is no guarantee that the optimal solution will be found, although generally, the algorithm will return a good solution if possible.","category":"page"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"The genetic programming algorithm starts with a random population of solutions, which are represented by trees, and then using a fitness function, it repeats the process of selecting the parents, performing the cross between them, applying a mutation on the child solutions, and, finally set a new generation choice between parents and children. This process is repeated until a stop criteria is met.","category":"page"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"GP-NLS creates symbolic trees but expands them by adding an intercept, slope, and a coefficient to every variable. The new free parameters are then adjusted using the non-linear optimization method called Levenberg-Marquardt.","category":"page"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"(Image: expanded tree)","category":"page"},{"location":"#Functions-visible-by-import","page":"GP_NLS in Julia","title":"Functions visible by import","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"The functions that are exported are listed below. ","category":"page"},{"location":"#Types","page":"GP_NLS in Julia","title":"Types","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"Func\nConst\nVar\nWeightedVar\nERC      ","category":"page"},{"location":"#Default-sets","page":"GP_NLS in Julia","title":"Default sets","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"defaultFunctionSet\ndefaultConstSet\ndefaultERCSet     ","category":"page"},{"location":"#Auxiliary-functions","page":"GP_NLS in Julia","title":"Auxiliary functions","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"evaluate\ngetstring\nnumberofnodes\ndepth\ntrue_numberofnodes\ntrue_depth        ","category":"page"},{"location":"#Genetic-Programming-algorithm","page":"GP_NLS in Julia","title":"Genetic Programming algorithm","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"GP\nfitness","category":"page"},{"location":"#All-functions","page":"GP_NLS in Julia","title":"All functions","text":"","category":"section"},{"location":"","page":"GP_NLS in Julia","title":"GP_NLS in Julia","text":"The module has some built-in auxiliary functions that its external use is not recommended. All implementations are listed in the modules of the library, but only some functions are exported outside the package.","category":"page"},{"location":"unexported/#Unexported-functions","page":"Auxiliary functions (unexported)","title":"Unexported functions","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"The module has some built-in auxiliary functions that its external use is not recommended. All implementations are listed in the modules of the library, but only some functions are exported outside the package.","category":"page"},{"location":"unexported/#Tree-structural-nodes","page":"Auxiliary functions (unexported)","title":"Tree structural nodes","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"To build the expression trees, the defined structs are used. Those serves as the backbone of the tree, where every node has a different content.","category":"page"},{"location":"unexported/#Types-and-functions","page":"Auxiliary functions (unexported)","title":"Types and functions","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Modules = [GP_NLS]\r\nPublic  = false\r\nPages   = [\"TreeStructure.jl\"]","category":"page"},{"location":"unexported/#GP_NLS.AbstractNode","page":"Auxiliary functions (unexported)","title":"GP_NLS.AbstractNode","text":"Abstract type of our symbolic tree nodes. The idea of creating this type is to create subtypes InternalNode and TerminalNode, and then use multiple dispatch to implement functions that should have different behavior when manipulating the expression trees.\n\nExpression trees should not be built using Var, WeightedVar, Const, Func, ERC, but with these nodes, which  are intended to be used as the \"backbone\" of the tree. The backbone is build using the InternalNode and TerminalNode, and its contents should be the ones declared in NodeContentjl.\n\nA terminal node must have as its contents only the types Const, Var, WeightedVar, and an internal nodemust have its contents the type Func.\n\nNotice that the ERC, when selected to be used in a terminal during the creation of a tree, is replaced by a random Const node). There are not any explicit ERC terminal in the trees.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GP_NLS.InternalNode","page":"Auxiliary functions (unexported)","title":"GP_NLS.InternalNode","text":"Struct to build the internal nodes of the backbone of the tree. Its contents will always be of the func type, a f ::Func function that will necessarily have f.arity children, where f.arity is the arity of the function.\n\nInternalNode(f::Func, children::Vector{AbstractNode}) <: AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GP_NLS.TerminalNode","page":"Auxiliary functions (unexported)","title":"GP_NLS.TerminalNode","text":"Struct to build the terminal nodes of the backbone of the tree. Its contents will always be of the terminal type: Union{Const, Var, WeightedVar}.\n\nTerminalNode(terminal::Union{Const, Var, WeightedVar}) <: AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"unexported/#Auxiliary-functions","page":"Auxiliary functions (unexported)","title":"Auxiliary functions","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Implementation of some auxiliary functions that are used to inspect and manipulate trees more generally.","category":"page"},{"location":"unexported/#Types-and-functions-2","page":"Auxiliary functions (unexported)","title":"Types and functions","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Modules = [GP_NLS]\r\nPublic  = false\r\nPages   = [\"Utils.jl\"]","category":"page"},{"location":"unexported/#GP_NLS.branches_in_limits","page":"Auxiliary functions (unexported)","title":"GP_NLS.branches_in_limits","text":"Finds all branches of any tree node that have a number of nodes less than or equal to allowedSize and a depth less than or equal to allowedDepth . Returns a list with the position of all branches found.\n\nbranches_in_limits(\n    allowedSize::Int64, allowedDepth::Int64, node::AbstractNode, _point::Int64=1)::Vector{Int64}\n\nThe _point parameter being returned is for internal use, and serves to monitor the point of the tree where the candidates were found. This is only meaningful to recursive calls, and outside of the function it does not represent any useful information.\n\n\n\n\n\n","category":"function"},{"location":"unexported/#GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}","page":"Auxiliary functions (unexported)","title":"GP_NLS.change_at!","text":"Takes a point p of type integer (which must be less than or equal to the number of nodes of branch), a branch of type AbstractNode, and any node AbstractNode representing a tree. Returns a modification of the tree by inserting the branch into the tree at position `p. This function changes the tree passed as argument.\n\nchange_at!(p::Int64, branch::AbstractNode, node::AbstractNode)::AbstractNode\n\nThis method is mainly used to modify trees in the crossover operation.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}","page":"Auxiliary functions (unexported)","title":"GP_NLS.change_children!","text":"Function that takes a point p (which must be less than or equal to the number of nodes of branch), a branch of type AbstractNode, and a list of children Vector{AbstractNode}. Returns a modification of the list of children, where the p position node will be replaced by the given branch. This function changes the list of children passed as argument.\n\nchange_children!(p::Int64, branch::AbstractNode, children::Vector{AbstractNode})::Vector{AbstractNode}\n\nThis function is a helper to change_at!, and itsfor internal use. It is not exported by the module.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}","page":"Auxiliary functions (unexported)","title":"GP_NLS.copy_tree","text":"Function that takes any node of a tree (AbstractNode) and recursively recreates the structure so that references are not shared between the tree passed and the tree returned, avoiding side effects when manipulating the tree.\n\ncopy_tree(node::AbstractNode)::TerminalNode\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}","page":"Auxiliary functions (unexported)","title":"GP_NLS.get_branch_at","text":"Function that takes any node of a tree (AbstractNode) and an integer p (which must be less than or equal to the number of nodes in tree) and returns the branch at position p.\n\nget_branch_at(p::Int64, node::AbstractNode)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}","page":"Auxiliary functions (unexported)","title":"GP_NLS.get_depth_at","text":"Takes a point p of type integer (which must be less than or equal to the number of nodes of the node passed) and any node AbstractNode representing a tree, then this function find and return the depth of the subtree at position p.\n\nget_depth_at(p::Int64, node::AbstractNode)::Int64\n\nIt's almost like finding the depth of the tree, but when we are interested  in finding the depth of a subtree that is at the point p, not the whole tree depth.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}","page":"Auxiliary functions (unexported)","title":"GP_NLS.which_children","text":"Function that takes a set of children of the same node as the array children::Vector{AbstractNode}, and an integer p (which must be less than or equal to number of nodes in children) and finds the child containing the p-th node of the children if it was traversed inorder.\n\nReturns a tuple containing the child which contains the node of index p, and an integer informing the position of the p-th node within the returned (child) subtree.\n\nwhich_children(p::Int64, children::Vector{AbstractNode})::Tuple{Int64, AbstractNode}\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Tree-Evaluation","page":"Auxiliary functions (unexported)","title":"Tree Evaluation","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Functions that evaluate a tree for a given dataset and calculates its fitness.","category":"page"},{"location":"unexported/#Types-and-functions-3","page":"Auxiliary functions (unexported)","title":"Types and functions","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Modules = [GP_NLS]\r\nPublic  = false\r\nPages   = [\"Evaluation.jl\"]","category":"page"},{"location":"unexported/#Population-Initialization","page":"Auxiliary functions (unexported)","title":"Population Initialization","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Implementation of different functions to initialize individual trees, as well  as functions to create an entire population.","category":"page"},{"location":"unexported/#Types-and-functions-4","page":"Auxiliary functions (unexported)","title":"Types and functions","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Modules = [GP_NLS]\r\nPublic  = false\r\nPages   = [\"Initialization.jl\"]","category":"page"},{"location":"unexported/#GP_NLS.PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.PTC2","text":"Tree creation with the Probabilistic Tree Creator 2 (PTC2) method, described in Two Fast Tree-Creation Algorithms for Genetic Programming, by Sean Luke.\n\nThis method looks like Koza's full method, but in addition to respecting a limit of maxDepth depth, it also respects a limit of number of nodes  expctdSize.\n\nPTC2 ensures that the depth does not exceed the maximum (in our case, weighted variables count as depth 1), and ensures that the number of nodes does not exceed the expected value added to the highest arity between the functions, that is, expctdSize + max(arity(f)) f in fSet.\n\nPTC2(\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    maxDepth::Int64,\n    expctdSize::Int64)::AbstractNode\n\nHere we adopt that the chance to select a t terminal will be uniform for all possible terminals, and the chance to select a function will also follow the same logic.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS._create_random_terminal-Tuple{Array{Union{ERC, Const, Var, WeightedVar},1}}","page":"Auxiliary functions (unexported)","title":"GP_NLS._create_random_terminal","text":"Function that receives the set of terminal contents and creates a random terminal node.\n\n_create_random_terminal(\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}})::TerminalNode\n\nCreating a terminal node involves an additional verification step for the case of ERC, which must be replaced with a constant within the range specified.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.full","text":"Function that creates a tree using the full method, inspired by Koza's original work. Receives a set of fSet::Vector{Func} functions, a set of tSet::Vector{Union{Var, WeightedVar, Const, ERC}} terminals, and a maximum depth of maxDepth::Int64 allowed.\n\nReturns any tree with maximum depth maxDepth and using the contents of past functions and terminals.\n\nfull(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n        maxDepth::Int64)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.grow","text":"Function that creates a tree using the grow method, inspired by Koza's original work. Receives a set of fSet::Vector{Func} functions that will be used in the internal nodes, a set of tSet::Vector{Union{Var, WeightedVar, Const, ERC}} terminals, and a maximum depth of maxDepth::Int64 allowed.\n\nReturns any tree with maximum depth maxDepth created using the functions and terminal sets.\n\n grow(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n        maxDepth::Int64)::AbstractNode\n\nNote that there is no minimum size, meaning that a single-node tree can be returned. The maximum depth considers weighted variables as a single node.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.init_pop_PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.init_pop_PTC2","text":"Function that initializes a population of size popSize using the PTC2 method.\n\ninit_pop_PTC2(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nEvery initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.init_pop_full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.init_pop_full","text":"Function that initializes a population of size popSize using the full method.\n\ninit_pop_full(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nEvery initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.init_pop_grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.init_pop_grow","text":"Function that initializes a population of size popSize using the grow method.\n\ninit_pop_grow(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nEvery initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.init_pop_ramped-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.init_pop_ramped","text":"Function that initializes a population of size popSize using the ramped half-half method.\n\ninit_pop_ramped(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)\n\nEvery initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Non-linear-Least-Squares-optimization","page":"Auxiliary functions (unexported)","title":"Non-linear Least Squares optimization","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Implementation of auxiliary functions and the nonlinear optimization method of coefficients. All functions declared here are for internal use by the module.","category":"page"},{"location":"unexported/#Types-and-functions-5","page":"Auxiliary functions (unexported)","title":"Types and functions","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Modules = [GP_NLS]\r\nPublic  = false\r\nPages   = [\"LsqOptimization.jl\"]","category":"page"},{"location":"unexported/#GP_NLS.adaptate_tree-Tuple{GP_NLS.AbstractNode}","page":"Auxiliary functions (unexported)","title":"GP_NLS.adaptate_tree","text":"Function that receives a tree and makes the necessary adaptations to be able to apply the optimization with the nonlinear least squares method. Does not modify the arguments. Returns a function that receives X and theta to perform tree evaluation, the initial theta vector (which corresponds to the original coefficients of the tree before the optimization process), and the adapted tree.\n\nadaptate_tree(node::AbstractNode)::Tuple{Function, Vector{Float64}, AbstractNode}\n\nThe adaptation is done by adding 4 new nodes in the tree, to create the linear transformation box (it adds an intercept and a slope to the tree). This function The returned function takes as arguments X::Matrix{Float64} and theta::Vector{Float64} to perform the evaluation (evaluate). The H function returned is internally used in an autodiff algorithm to obtain the Jacobian in the optimization method.\n\nThis function is for the internal use of the package, and is used in the     optimization method.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.apply_local_opt","page":"Auxiliary functions (unexported)","title":"GP_NLS.apply_local_opt","text":"Function that receives a node of a tree (AbstractNode), an array with the X::Matrix{Float64} training data, and an array with expected values y::Vector{Float64}, and applies the optimization process of non-linear least squares. Returns an adjusted tree.\n\napply_local_opt(\n    node::AbstractNode, X::Matrix{Float64},\n    y::Vector{Float64}, keep_linear_transf_box=false)::AbstractNode\n\nWe can choose to return the expression with/without the transformation box. In case it is returned, it is worth noting that the code will not apply mutation or crossover at the nodes of the block.\n\nThis function is for the internal use of the package, and is used in the     optimization method.\n\n\n\n\n\n","category":"function"},{"location":"unexported/#GP_NLS.evaluate_replacing_consts","page":"Auxiliary functions (unexported)","title":"GP_NLS.evaluate_replacing_consts","text":"Function that evaluates the tree simulating that the constants were replaced by the theta values. The idea is to simulate the replacement without the need of completely rebuild the tree, aiming to reduce the computational cost when the optimization method performs many iterations.\n\nevaluate_replacing_consts(\n    node::Union{TerminalNode, InternalNode}, X::Matrix{Float64},\n    theta::Vector{Float64}, c_idx::Int64=0)::Tuple{Vector{Float64}, Int64}\n\nThe c_idx variable is used internally to keep track of the indexes of theta that have already been used or not, so that the replacement simulation is done correctly.\n\nThis function is for the internal use of the package, and is used in the optimization method. Implements multiple dispatch.    \n\n\n\n\n\n","category":"function"},{"location":"unexported/#GP_NLS.find_const_nodes","page":"Auxiliary functions (unexported)","title":"GP_NLS.find_const_nodes","text":"Function that takes a node of a tree (AbstractNode) and traverses it recursively, looking for all terminal nodes that have as content a Const or a WeightedVar. This function makes internal use of a list of nodes Vector{AbstractNode}, which is passed by reference to the calls recursively. The recursive calls will add a reference to the nodes found in this list.\n\nfind_const_nodes(\n    node::AbstractNode, nodes=Vector{AbstractNode}())::Vector{TerminalNode}\n\nThis function is for the internal use of the package, and is used in the optimization method.\n\n\n\n\n\n","category":"function"},{"location":"unexported/#GP_NLS.replace_const_nodes","page":"Auxiliary functions (unexported)","title":"GP_NLS.replace_const_nodes","text":"Function that takes a node of a tree (AbstractNode) and a vector of type theta::Vector{Float64} with the same number of elements as the number of constants from the given tree, and recursively replaces the constants of the tree. This is the update step of the GP-NLS algorithm, where we take new vales for the constants and replace them in the original tree with the elements of theta. This function does not change the arguments passed, and returns a new tree.\n\nThe theta must have the same number of the total count of Const and WeightedVar nodes in the tree.\n\nreplace_const_nodes(\n    node::AbstractNode, theta::Vector{Float64}, _first_of_stack=true)::AbstractNode\n\nThe _first_of_stack argument is for internal use of the function. It is used to create a copy of theta where is safe to remove elements without changing the original vector.\n\nThis function is for the internal use of the package, and is used in the optimization method.\n\n\n\n\n\n","category":"function"},{"location":"unexported/#Genetic-Programming-algorithm","page":"Auxiliary functions (unexported)","title":"Genetic Programming algorithm","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Mutation, crossover and GP implementation.","category":"page"},{"location":"unexported/#Types-and-functions-6","page":"Auxiliary functions (unexported)","title":"Types and functions","text":"","category":"section"},{"location":"unexported/","page":"Auxiliary functions (unexported)","title":"Auxiliary functions (unexported)","text":"Modules = [GP_NLS]\r\nPublic  = false\r\nPages   = [\"Evolutionary.jl\"]","category":"page"},{"location":"unexported/#GP_NLS.crossover-Tuple{GP_NLS.AbstractNode,GP_NLS.AbstractNode,Int64,Int64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.crossover","text":"Crossover function that does a recombination of the two parents passed as an argument, finding a breakpoint in each of the parent trees and swapping the subtree between those breakpoints. It doesn't change the parents. This crossover controls the number of nodes (not the depth) of the tree, avoiding to  exceed the maximum value.\n\ncrossover(\n    fst_parent::AbstractNode,\n    snd_parent::AbstractNode,\n    maxDepth::Int64,\n    maxSize::Int64)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.mutation!-Tuple{GP_NLS.AbstractNode,Int64,Int64,Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Float64}","page":"Auxiliary functions (unexported)","title":"GP_NLS.mutation!","text":"Function that implements a traditional substitution mutation in a tree, respecting the maximum past depth. Modifies the tree passed.\n\nmutation!(\n    node::AbstractNode,\n    maxDepth::Int64,\n    maxSize::Int64,\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    mutationRate::Float64)::AbstractNode\n\nThe mutationRate mutation rate should vary by 0 1 and determines the chance of occurring a mutation (replacing a random point with a new subtree). If no mutation is performed, then the given node is returned.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GP_NLS.tourn_selection-Tuple{Tuple{GP_NLS.AbstractNode,Float64},Tuple{GP_NLS.AbstractNode,Float64}}","page":"Auxiliary functions (unexported)","title":"GP_NLS.tourn_selection","text":"Function that receives two individuals and makes a simple tournament selection. An individual is a (fitness::Float64, node::AbstractNode) tuple with the tree and it fitness, to avoid recalculations all the time.\n\ntourn_selection(\n    ind1::Tuple{Float64, AbstractNode},\n    ind2::Tuple{Float64, AbstractNode})::Tuple{AbstractNode, Float64}\n\nThe return type is a tuple with the winning individual(that is, the  individual winner tuple is returned).\n\n\n\n\n\n","category":"method"}]
}
