var documenterSearchIndex = {"docs":
[{"location":"Evolutionary/#Genetic-Programming-algorithm","page":"The GP Algorithm","title":"Genetic Programming algorithm","text":"","category":"section"},{"location":"Evolutionary/","page":"The GP Algorithm","title":"The GP Algorithm","text":"Mutation, crossover and GP implementation.","category":"page"},{"location":"Evolutionary/#Types-and-functions","page":"The GP Algorithm","title":"Types and functions","text":"","category":"section"},{"location":"Evolutionary/","page":"The GP Algorithm","title":"The GP Algorithm","text":"Modules = [GP_NLS]\r\nPages   = [\"Evolutionary.jl\"]","category":"page"},{"location":"Evolutionary/#GP_NLS.GP-Tuple{Array{Float64,2},Array{Float64,1},Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1}}","page":"The GP Algorithm","title":"GP_NLS.GP","text":"GP With depth and number of nodes control. The recommended startup is PTC2, but we have the others as well (however, the other methods are based in the koza GP and do not follow restrictions on the maximum number of nodes). To use canonic GP, just disable lm_optimization and choose one of  [\"ramped\", \"grow\", \"full\"] initializations. To use GP-NLS, turn on  lm_optimization and use \"PTC2\" as initialization method.\n\nGP(\n    X::Matrix{Float64}, \n    y::Vector{Float64},\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    minDepth::Int64        = 1,\n    maxDepth::Int64        = 5,\n    maxSize::Int64         = 25,\n    popSize::Int64         = 50,\n    gens::Int64            = 50,\n    mutationRate::Float64  = 0.25,\n    elitism::Bool          = false,\n    verbose::Bool          = false,\n    init_method::String    = \"PTC2\", #[\"ramped\", \"grow\", \"full\", \"PTC2\"]\n    lm_optimization        = false, \n    keep_linear_transf_box = false\n)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#GP_NLS.crossover-Tuple{GP_NLS.AbstractNode,GP_NLS.AbstractNode,Int64,Int64}","page":"The GP Algorithm","title":"GP_NLS.crossover","text":"Crossover function that does a recombination of the two parents passed as an argument, finding a breakpoint in each of the parent trees and swapping the subtree between those breakpoints. It doesn't change the parents. This crossover controls the number of nodes (not the depth) of the tree, avoiding to  exceed the maximum value.\n\ncrossover(\n    fst_parent::AbstractNode,\n    snd_parent::AbstractNode,\n    maxDepth::Int64,\n    maxSize::Int64)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#GP_NLS.mutation!-Tuple{GP_NLS.AbstractNode,Int64,Int64,Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Float64}","page":"The GP Algorithm","title":"GP_NLS.mutation!","text":"Function that implements a traditional substitution mutation in a tree, respecting the maximum past depth. Modifies the tree passed.\n\nmutation!(\n    node::AbstractNode,\n    maxDepth::Int64,\n    maxSize::Int64,\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    mutationRate::Float64)::AbstractNode\n\nThe mutationRate mutation rate should vary by 0 1 and determines the chance of occurring a mutation (replacing a random point with a new subtree). If no mutation is performed, then the given node is returned.\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#GP_NLS.tourn_selection-Tuple{Tuple{GP_NLS.AbstractNode,Float64},Tuple{GP_NLS.AbstractNode,Float64}}","page":"The GP Algorithm","title":"GP_NLS.tourn_selection","text":"Function that receives two individuals and makes a simple tournament selection. An individual is a (fitness::Float64, node::AbstractNode) tuple with the tree and it fitness, to avoid recalculations all the time.\n\ntourn_selection(\n    ind1::Tuple{Float64, AbstractNode},\n    ind2::Tuple{Float64, AbstractNode})::Tuple{AbstractNode, Float64}\n\nThe return type is a tuple with the winning individual(that is, the  individual winner tuple is returned).\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#Population-Initialization","page":"Population initialization","title":"Population Initialization","text":"","category":"section"},{"location":"Initialization/","page":"Population initialization","title":"Population initialization","text":"Implementation of different functions to initialize individual trees, as well  as functions to create an entire population.","category":"page"},{"location":"Initialization/#Types-and-functions","page":"Population initialization","title":"Types and functions","text":"","category":"section"},{"location":"Initialization/","page":"Population initialization","title":"Population initialization","text":"Modules = [GP_NLS]\r\nPages   = [\"Initialization.jl\"]","category":"page"},{"location":"Initialization/#GP_NLS.PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64}","page":"Population initialization","title":"GP_NLS.PTC2","text":"Tree creation with the Probabilistic Tree Creator 2 (PTC2) method, described in Two Fast Tree-Creation Algorithms for Genetic Programming, by Sean Luke.\n\nThis method looks like Koza's full method, but in addition to respecting a limit of maxDepth depth, it also respects a limit of number of nodes  expctdSize.\n\nPTC2 ensures that the depth does not exceed the maximum (in our case, weighted variables count as depth 1), and ensures that the number of nodes does not exceed the expected value added to the highest arity between the functions, that is, expctdSize + max(arity(f)) f in fSet.\n\nPTC2(\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    maxDepth::Int64,\n    expctdSize::Int64)::AbstractNode\n\nHere we adopt that the chance to select a t terminal will be uniform for all possible terminals, and the chance to select a function will also follow the same logic.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS._create_random_terminal-Tuple{Array{Union{ERC, Const, Var, WeightedVar},1}}","page":"Population initialization","title":"GP_NLS._create_random_terminal","text":"Function that receives the set of terminal contents and creates a random terminal node.\n\n_create_random_terminal(\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}})::TerminalNode\n\nCreating a terminal node involves an additional verification step for the case of ERC, which must be replaced with a constant within the range specified.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}","page":"Population initialization","title":"GP_NLS.full","text":"Function that creates a tree using the full method, inspired by Koza's original work. Receives a set of fSet::Vector{Func} functions, a set of tSet::Vector{Union{Var, WeightedVar, Const, ERC}} terminals, and a maximum depth of maxDepth::Int64 allowed.\n\nReturns any tree with maximum depth maxDepth and using the contents of past functions and terminals.\n\nfull(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n        maxDepth::Int64)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}","page":"Population initialization","title":"GP_NLS.grow","text":"Function that creates a tree using the grow method, inspired by Koza's original work. Receives a set of fSet::Vector{Func} functions that will be used in the internal nodes, a set of tSet::Vector{Union{Var, WeightedVar, Const, ERC}} terminals, and a maximum depth of maxDepth::Int64 allowed.\n\nReturns any tree with maximum depth maxDepth created using the functions and terminal sets.\n\n grow(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n        maxDepth::Int64)::AbstractNode\n\nNote that there is no minimum size, meaning that a single-node tree can be returned. The maximum depth considers weighted variables as a single node.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Population initialization","title":"GP_NLS.init_pop_PTC2","text":"Function that initializes a population of size popSize using the PTC2 method.\n\ninit_pop_PTC2(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nEvery initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Population initialization","title":"GP_NLS.init_pop_full","text":"Function that initializes a population of size popSize using the full method.\n\ninit_pop_full(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nEvery initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Population initialization","title":"GP_NLS.init_pop_grow","text":"Function that initializes a population of size popSize using the grow method.\n\ninit_pop_grow(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nEvery initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_ramped-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Population initialization","title":"GP_NLS.init_pop_ramped","text":"Function that initializes a population of size popSize using the ramped half-half method.\n\ninit_pop_ramped(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)\n\nEvery initialization functions take the same parameters, but not all do of them makes use of all parameters. This is just to unify the call of initialization functions.\n\n\n\n\n\n","category":"method"},{"location":"Evaluation/#Tree-Evaluation","page":"Tree evaluation","title":"Tree Evaluation","text":"","category":"section"},{"location":"Evaluation/","page":"Tree evaluation","title":"Tree evaluation","text":"Functions that evaluate a tree for a given dataset and calculates its fitness.","category":"page"},{"location":"Evaluation/#Types-and-functions","page":"Tree evaluation","title":"Types and functions","text":"","category":"section"},{"location":"Evaluation/","page":"Tree evaluation","title":"Tree evaluation","text":"Modules = [GP_NLS]\r\nPages   = [\"Evaluation.jl\"]","category":"page"},{"location":"Evaluation/#GP_NLS.evaluate-Tuple{GP_NLS.TerminalNode,Array{Float64,2}}","page":"Tree evaluation","title":"GP_NLS.evaluate","text":"Function that takes any node of a tree (AbstractNode), and an data matrix X (where each row is an observation and each column is a variable), and evaluate the prediction for each observation in X. The function makes a recursive call along the tree node and evaluates the expression using the matrix variable columns that exist in the tree.\n\nIf the node is a InternalNode, the recursive call is made with its children and the result is used as arguments of the node function.\n\nIf it is a TerminalNode with content Const, a vector with size(X, 1) repeatedly containing the constant is returned.\n\nIf it is a TerminalNode with content Var or WeightedVar, the column of the index Var.var_idx of X will be used to extract  the value of the variable from the matrix.\n\nevaluate(node::Union{TerminalNode, InternalNode}, X::Matrix{Float64})::Vector{Float64}\n\nImplements a multiple dispatch for the case of TerminalNode and InternalNode.\n\n\n\n\n\n","category":"method"},{"location":"Evaluation/#GP_NLS.fitness-Tuple{GP_NLS.AbstractNode,Array{Float64,2},Array{Float64,1}}","page":"Tree evaluation","title":"GP_NLS.fitness","text":"Function that measures the fitness of a given tree, in relation to an training data matrix X::Matrix{Float64} and a vector of expected results y::Vector{Float64}.\n\nfitness(tree::AbstractNode, X::Matrix{Float64}, y::Vector{Float64})::Float64\n\nThe fitness is calculated using the RMSE, and this method returns an infinite fitness if the tree fails to evaluate –- forcing the selective pressure to likely eliminate the individual from the population without having to think about protected operations.\n\n\n\n\n\n","category":"method"},{"location":"Nodes/#Node-contents","page":"Node contents","title":"Node contents","text":"","category":"section"},{"location":"Nodes/","page":"Node contents","title":"Node contents","text":"All representation by trees starts here. These Structs are used as content of the nodes of the tree (and not as direct nodes).","category":"page"},{"location":"Nodes/#Types-and-functions","page":"Node contents","title":"Types and functions","text":"","category":"section"},{"location":"Nodes/","page":"Node contents","title":"Node contents","text":"Modules = [GP_NLS]\r\nPages   = [\"NodeContent.jl\"]","category":"page"},{"location":"Nodes/#GP_NLS.defaultConstSet","page":"Node contents","title":"GP_NLS.defaultConstSet","text":"Default const set\n\nConst(3.1415),\nConst(1.0),\nConst(-1.0)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.defaultERCSet","page":"Node contents","title":"GP_NLS.defaultERCSet","text":"Default ERC set\n\nERC(-1.0, 1.0)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.defaultFunctionSet","page":"Node contents","title":"GP_NLS.defaultFunctionSet","text":"Default functions set\n\nFunc(+, 2),\nFunc(-, 2),\nFunc(myprod, 2),\nFunc(mydiv, 2),\n\nFunc(mysquare, 1),\nFunc(mysqrt, 1),\nFunc(myexp, 1),\nFunc(mylog, 1)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.Const","page":"Node contents","title":"GP_NLS.Const","text":"Struct to be the content of an terminal node of an expression tree. This struct represents a Float64 constant value.\n\nConst(v::Float64)\n\nReceives a Float64 value v which will be used as a constant.\n\nThe representation of the constant as string is obtained by rounding the value to 3 decimal places, and it is automatically obtained.\n\nWhen using non-linear optimization, the nonlinear least squares optimization method looks for this struct specifically to optimize their values.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.ERC","page":"Node contents","title":"GP_NLS.ERC","text":"Struct to be the content of an terminal node of an expression tree. This struct keeps the range limits for creating a random constant with the ERC method.\n\nERC(lb::Float64, ub::Float64)\n\nThis struct is used to create constants in the terminal nodes. When it is selected to be a terminal, a new terminal will be created with the struct Const with a random value drawn between [lb, ub) to take the place of the ERC (Ephemeral Random Constant) at the terminal node. The string representation of the created constant is as described in Const documentation.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.Func","page":"Node contents","title":"GP_NLS.Func","text":"Struct to be the content of an internal node of an expression tree.\n\nFunc(f::Function, a::Int64)\n\nTakes a function f and the arity a of the function. The function must always work in vectorized form (will always receive a arrays with n values, where each value of the array is an observation). So the function input will have a rows and n columns when this node is being evaluated in other methods.\n\nThe function's representation as a string is inferred from the name of the function passed, and when this node is used to create a node of a tree, it will have a children.\n\nWhen creating new functions, protected operators must not be used. The  non-linear optimization method uses autodiff to differentiate the tree, and complex functions can be problematic to automatically differentiate.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.Var","page":"Node contents","title":"GP_NLS.Var","text":"Struct to be the content of a terminal node of an expression tree. This struct represents a variable of the data set.\n\nVar(v::String, i::Int64)\n\nReceives a string v that will be used as the representation of the variable when printing the expression (you can use a placeholder if the database do not have column names) and a ì index that matches the column index of the corresponding variable in the observations.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.WeightedVar","page":"Node contents","title":"GP_NLS.WeightedVar","text":"Struct to be the content of a terminal node of an expression tree. This struct represents a weighted variable, that have a coefficient associated with it at the time of creation.\n\nWeightedVar(v::String, i::Int64)\n\nThis struct represents a weighted variable, that can be adjusted with  the non-linear least squares method.\n\nThe String representation is inferred as the same way when creating a Var and the coefficient is inferred in the same way as a Const.\n\nWeightedVar(v::String, i::Int64, w::Float64)\n\nAdditionally, you can force a specific coefficient by passing the value as the third argument on the constructor. When no value is specified, the coefficient is set to 1.0.\n\nThis weighted variable is a subtree with 3 nodes and depth 2, but in practice it is treated as a single node, as it is not of interest to make the dissociation between the weight and the variable during the GP process. By treating the weighted variable as a single node, it is not necessary to modify the crossover or mutation implementations to prevent changing the subtree.\n\n\n\n\n\n","category":"type"},{"location":"Trees/#Tree-structural-nodes","page":"Tree structures","title":"Tree structural nodes","text":"","category":"section"},{"location":"Trees/","page":"Tree structures","title":"Tree structures","text":"To build the expression trees, the defined structs are used. Those serves as the backbone of the tree, where every node has a different content.","category":"page"},{"location":"Trees/#Types-and-functions","page":"Tree structures","title":"Types and functions","text":"","category":"section"},{"location":"Trees/","page":"Tree structures","title":"Tree structures","text":"Modules = [GP_NLS]\r\nPages   = [\"TreeStructure.jl\"]","category":"page"},{"location":"Trees/#GP_NLS.AbstractNode","page":"Tree structures","title":"GP_NLS.AbstractNode","text":"Abstract type of our symbolic tree nodes. The idea of creating this type is to create subtypes InternalNode and TerminalNode, and then use multiple dispatch to implement functions that should have different behavior when manipulating the expression trees.\n\nExpression trees should not be built using Var, WeightedVar, Const, Func, ERC, but with these nodes, which  are intended to be used as the \"backbone\" of the tree. The backbone is build using the InternalNode and TerminalNode, and its contents should be the ones declared in NodeContentjl.\n\nA terminal node must have as its contents only the types Const, Var, WeightedVar, and an internal nodemust have its contents the type Func.\n\nNotice that the ERC, when selected to be used in a terminal during the creation of a tree, is replaced by a random Const node). There are not any explicit ERC terminal in the trees.\n\n\n\n\n\n","category":"type"},{"location":"Trees/#GP_NLS.InternalNode","page":"Tree structures","title":"GP_NLS.InternalNode","text":"Struct to build the internal nodes of the backbone of the tree. Its contents will always be of the func type, a f ::Func function that will necessarily have f.arity children, where f.arity is the arity of the function.\n\nInternalNode(f::Func, children::Vector{AbstractNode}) <: AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"Trees/#GP_NLS.TerminalNode","page":"Tree structures","title":"GP_NLS.TerminalNode","text":"Struct to build the terminal nodes of the backbone of the tree. Its contents will always be of the terminal type: Union{Const, Var, WeightedVar}.\n\nTerminalNode(terminal::Union{Const, Var, WeightedVar}) <: AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"LsqOptimization/#Non-linear-Least-Squares-optimization","page":"Non-linear optimization","title":"Non-linear Least Squares optimization","text":"","category":"section"},{"location":"LsqOptimization/","page":"Non-linear optimization","title":"Non-linear optimization","text":"Implementation of auxiliary functions and the nonlinear optimization method of coefficients. All functions declared here are for internal use by the module.","category":"page"},{"location":"LsqOptimization/#Types-and-functions","page":"Non-linear optimization","title":"Types and functions","text":"","category":"section"},{"location":"LsqOptimization/","page":"Non-linear optimization","title":"Non-linear optimization","text":"Modules = [GP_NLS]\r\nPages   = [\"Evolutionary.jl\"]","category":"page"},{"location":"Utils/#Auxiliary-functions","page":"Utility functions","title":"Auxiliary functions","text":"","category":"section"},{"location":"Utils/","page":"Utility functions","title":"Utility functions","text":"Implementation of some auxiliary functions that are used to inspect and manipulate trees more generally.","category":"page"},{"location":"Utils/#Types-and-functions","page":"Utility functions","title":"Types and functions","text":"","category":"section"},{"location":"Utils/","page":"Utility functions","title":"Utility functions","text":"Modules = [GP_NLS]\r\nPages   = [\"Utils.jl\"]","category":"page"},{"location":"Utils/#GP_NLS.branches_in_limits","page":"Utility functions","title":"GP_NLS.branches_in_limits","text":"Finds all branches of any tree node that have a number of nodes less than or equal to allowedSize and a depth less than or equal to allowedDepth . Returns a list with the position of all branches found.\n\nbranches_in_limits(\n    allowedSize::Int64, allowedDepth::Int64, node::AbstractNode, _point::Int64=1)::Vector{Int64}\n\nThe _point parameter being returned is for internal use, and serves to monitor the point of the tree where the candidates were found. This is only meaningful to recursive calls, and outside of the function it does not represent any useful information.\n\n\n\n\n\n","category":"function"},{"location":"Utils/#GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}","page":"Utility functions","title":"GP_NLS.change_at!","text":"Takes a point p of type integer (which must be less than or equal to the number of nodes of branch), a branch of type AbstractNode, and any node AbstractNode representing a tree. Returns a modification of the tree by inserting the branch into the tree at position `p. This function changes the tree passed as argument.\n\nchange_at!(p::Int64, branch::AbstractNode, node::AbstractNode)::AbstractNode\n\nThis method is mainly used to modify trees in the crossover operation.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}","page":"Utility functions","title":"GP_NLS.change_children!","text":"Function that takes a point p (which must be less than or equal to the number of nodes of branch), a branch of type AbstractNode, and a list of children Vector{AbstractNode}. Returns a modification of the list of children, where the p position node will be replaced by the given branch. This function changes the list of children passed as argument.\n\nchange_children!(p::Int64, branch::AbstractNode, children::Vector{AbstractNode})::Vector{AbstractNode}\n\nThis function is a helper to change_at!, and itsfor internal use. It is not exported by the module.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.copy_tree","text":"Function that takes any node of a tree (AbstractNode) and recursively recreates the structure so that references are not shared between the tree passed and the tree returned, avoiding side effects when manipulating the tree.\n\ncopy_tree(node::AbstractNode)::TerminalNode\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.depth-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.depth","text":"Function that takes any node of a tree (AbstractNode) and recursively finds the depth of the tree, where the depth is the size of its largest branch. This depth function does not take into count the coefficients of weighted variables (which are, in fact, a subtree with depth 2). To find the depth of a tree considering weighted variables as a subtree (and not as a single node), use the function true_depth.\n\ndepth(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}","page":"Utility functions","title":"GP_NLS.get_branch_at","text":"Function that takes any node of a tree (AbstractNode) and an integer p (which must be less than or equal to the number of nodes in tree) and returns the branch at position p.\n\nget_branch_at(p::Int64, node::AbstractNode)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}","page":"Utility functions","title":"GP_NLS.get_depth_at","text":"Takes a point p of type integer (which must be less than or equal to the number of nodes of the node passed) and any node AbstractNode representing a tree, then this function find and return the depth of the subtree at position p.\n\nget_depth_at(p::Int64, node::AbstractNode)::Int64\n\nIt's almost like finding the depth of the tree, but when we are interested  in finding the depth of a subtree that is at the point p, not the whole tree depth.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.getstring-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.getstring","text":"Function that takes any node of a tree (AbstractNode) and recursively builds a string representation of the tree, where functions are always denoted in prefixed notation, with arguments in parentheses.\n\ngetstring(node::AbstractNode)::String\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.numberofnodes-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.numberofnodes","text":"Function that takes any node of a tree (AbstractNode) and recursively counts the total number of nodes of the tree. This function counts weighted variables as a single node. To find the number of nodes of a tree considering weighted variables as a subtree (and not as a single node), use the function true_numberofnodes.\n\nnumberofnodes(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.true_depth-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.true_depth","text":"Function that takes any node of a tree (AbstractNode) and recursively finds the depth of the tree, where the depth is the size of its largest branch. This depth function returns a value that corresponds to the number of existing nodes in the tree, considering weighted variables as being a subtree of depth 2. This function is not used in implementations, and is available to users who want to get the real depth of GP-NLS trees.\n\ntrue_depth(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.true_numberofnodes-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.true_numberofnodes","text":"Function that takes any node of a tree (AbstractNode) and recursively counts the total number of nodes of the tree. This function counts weighted  variables as three nodes. This function is only used in mutate, crossover, and initialize operations to avoid creating trees larger than the allowed.\n\ntrue_numberofnodes(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}","page":"Utility functions","title":"GP_NLS.which_children","text":"Function that takes a set of children of the same node as the array children::Vector{AbstractNode}, and an integer p (which must be less than or equal to number of nodes in children) and finds the child containing the p-th node of the children if it was traversed inorder.\n\nReturns a tuple containing the child which contains the node of index p, and an integer informing the position of the p-th node within the returned (child) subtree.\n\nwhich_children(p::Int64, children::Vector{AbstractNode})::Tuple{Int64, AbstractNode}\n\n\n\n\n\n","category":"method"},{"location":"#GP_NLS-in-Julia-Documentation","page":"GP_NLS","title":"GP_NLS in Julia Documentation","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"Implementation of a Symbolic Regression Algorithm with the Tree Representation and the possibility of using a non-linear optimization method to adjust the coefficients of  the trees during the evolutionary process.","category":"page"},{"location":"#About","page":"GP_NLS","title":"About","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"TODO.","category":"page"},{"location":"#Functions-visible-by-import","page":"GP_NLS","title":"Functions visible by import","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"The functions that are actually exported are listed below.","category":"page"},{"location":"#Types","page":"GP_NLS","title":"Types","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"Func\nConst\nVar\nWeightedVar\nERC      ","category":"page"},{"location":"#Default-sets","page":"GP_NLS","title":"Default sets","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"defaultFunctionSet\ndefaultConstSet\ndefaultERCSet     ","category":"page"},{"location":"#Auxiliary-functions","page":"GP_NLS","title":"Auxiliary functions","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"evaluate\ngetstring\nnumberofnodes\ndepth\ntrue_numberofnodes\ntrue_depth        ","category":"page"},{"location":"#Genetic-Programming-algorithm","page":"GP_NLS","title":"Genetic Programming algorithm","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"GP\nfitness","category":"page"},{"location":"#All-functions","page":"GP_NLS","title":"All functions","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"The module has some built-in auxiliary functions that its external use is not recommended. All implementations are listed in the modules of the library, but only some functions are exported outside the package.","category":"page"}]
}
