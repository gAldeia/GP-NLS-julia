var documenterSearchIndex = {"docs":
[{"location":"#Documentação-de-GP_NLS","page":"GP_NLS","title":"Documentação de GP_NLS","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"Implementação de um algoritmo de regressão simbólica com representação por árvores e possibilidade de uso de um método de otimização não linear para ajuste dos coeficientes.","category":"page"},{"location":"#Sobre","page":"GP_NLS","title":"Sobre","text":"","category":"section"},{"location":"#Funções-visíveis-pelo-import","page":"GP_NLS","title":"Funções visíveis pelo import","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"As funções que são de fato exportadas estão indicadas na barra de navegação.","category":"page"},{"location":"#Funções-internas","page":"GP_NLS","title":"Funções internas","text":"","category":"section"},{"location":"","page":"GP_NLS","title":"GP_NLS","text":"A biblioteca conta com algumas funções internas auxiliares que seu uso não é recomendado. Todas as implementações encontram-se listadas nos módulos da  biblioteca, mas apenas algumas são exportadas para fora do pacote.","category":"page"},{"location":"Evolutionary/#Algoritmo-evolutivo","page":"The GP Algorithm","title":"Algoritmo evolutivo","text":"","category":"section"},{"location":"Evolutionary/","page":"The GP Algorithm","title":"The GP Algorithm","text":"Implementação da mutação, crossover e GP.","category":"page"},{"location":"Evolutionary/#Tipos-e-Funções","page":"The GP Algorithm","title":"Tipos e Funções","text":"","category":"section"},{"location":"Evolutionary/","page":"The GP Algorithm","title":"The GP Algorithm","text":"Modules = [GP_NLS]\r\nPages   = [\"Evolutionary.jl\"]","category":"page"},{"location":"Evolutionary/#GP_NLS.GP","page":"The GP Algorithm","title":"GP_NLS.GP","text":"GP Com controle de profundidade e número de nós. A inicialização recomendada é a PTC2, mas temos as outras também (entretanto, os outros métodos são baseados no GP do koza e não seguem restrição de número máximo de nós).\n\nGP(\n    X::Matrix{Float64}, \n    y::Vector{Float64},\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    minDepth::Int64        = 1,\n    maxDepth::Int64        = 5,\n    maxSize::Int64         = 25,\n    popSize::Int64         = 50,\n    gens::Int64            = 50,\n    mutationRate::Float64  = 0.25,\n    elitism::Bool          = false,\n    verbose::Bool          = false,\n    init_method::String    = \"PTC2\", #[\"ramped\", \"grow\", \"full\", \"PTC2\"]\n    lm_optimization        = false, \n    keep_linear_transf_box = false\n)::AbstractNode\n\n\n\n\n\n","category":"function"},{"location":"Evolutionary/#GP_NLS.crossover-Tuple{GP_NLS.AbstractNode,GP_NLS.AbstractNode,Int64,Int64}","page":"The GP Algorithm","title":"GP_NLS.crossover","text":"Função de crossover que faz uma recombinação dos dois pais passados como argumento, encontrando um ponto de quebra em cada uma das árvores pais e trocando a subárvore entre esses pontos. Não modifica os pais. Esse crossover controla o número de nós (e não a profundidade).\n\ncrossover(\n    fst_parent::AbstractNode,\n    snd_parent::AbstractNode,\n    maxDepth::Int64,\n    maxSize::Int64)::AbstractNode\n\nQueremos que o crossover ocorra em um ponto de corte que não causa o aumento da árvore filha para algo maior que o limite.\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#GP_NLS.mutation!-Tuple{GP_NLS.AbstractNode,Int64,Int64,Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Float64}","page":"The GP Algorithm","title":"GP_NLS.mutation!","text":"Função que implementa uma mutação tradicional de substituição em uma árvore, respeitando a  profundidade máxima passada. Modifica a árvore passada.\n\nmutation!(\n    node::AbstractNode,\n    maxDepth::Int64,\n    maxSize::Int64,\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    mutationRate::Float64\n)::AbstractNode\n\nA taxa de mutação mutationRate deve variar em 0 1 e determina a chance de ocorrer uma mutação (substituindo um ponto aleatório por uma nova sub-árvore) ou o próprio nó passado ser retornado.\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#GP_NLS.tourn_selection-Tuple{Tuple{GP_NLS.AbstractNode,Float64},Tuple{GP_NLS.AbstractNode,Float64}}","page":"The GP Algorithm","title":"GP_NLS.tourn_selection","text":"Função que recebe dois indivíduos e faz uma seleção por torneio simples. Um indivíduo é uma tupla (fitness::Float64, node::AbstractNode) com a árvore e seu fitness, para evitar que seja recalculado a todo instante.\n\ntourn_selection(ind1::Tuple{Float64, AbstractNode}, ind2::Tuple{Float64, AbstractNode})::Tuple{AbstractNode, Float64}\n\nO retorno é uma tupla com o indivíduo vencedor (ou seja, é retornada uma tupla).\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#Índice","page":"The GP Algorithm","title":"Índice","text":"","category":"section"},{"location":"Evolutionary/","page":"The GP Algorithm","title":"The GP Algorithm","text":"","category":"page"},{"location":"Initialization/#Inicialização-da-população","page":"Population initialization","title":"Inicialização da população","text":"","category":"section"},{"location":"Initialization/","page":"Population initialization","title":"Population initialization","text":"Implementação de diferentes funções para criar árvores, e funções que criam uma população inteira","category":"page"},{"location":"Initialization/#Tipos-e-Funções","page":"Population initialization","title":"Tipos e Funções","text":"","category":"section"},{"location":"Initialization/","page":"Population initialization","title":"Population initialization","text":"Modules = [GP_NLS]\r\nPages   = [\"Initialization.jl\"]","category":"page"},{"location":"Initialization/#GP_NLS.PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64}","page":"Population initialization","title":"GP_NLS.PTC2","text":"Criação de árvores com o método Probabilistic Tree Creator 2 (PTC2), descrito em Two Fast Tree-Creation Algorithms for Genetic Programming, de Sean Luke.\n\nEsse método se parece com o método full de Koza, mas além de respeitar um limite de  profundidade maxDepth, respeita um limite de quantidade de nós expctdSize. O PTC2 garante que a profundidade não ultrapasse o máximo (no nosso caso, variáveis com peso contam como profundidade 1), e garante que o número de nós não ultrapasse o valor esperado somado da maior aridade entre as funções, isso é, expctdSize + max(aridade(f)) f in fSet.\n\nPTC2(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    maxDepth::Int64,\n    expctdSize::Int64)::AbstractNode\n\nAqui adotamos que a chance de selecionar um terminal t quando for necessário inserir um terminal será uniforme para todos os terminais, e a chance de inserir uma função  também seguirá a mesma lógica.\n\nO algoritmo do PTC2 é descrito em C e faz o uso de pilhas e ponteiros. Em Julia, não há todos esses recursos de forma simples, e uma adaptação dessas funções foi feita.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS._create_random_terminal-Tuple{Array{Union{ERC, Const, Var, WeightedVar},1}}","page":"Population initialization","title":"GP_NLS._create_random_terminal","text":"Função que recebe o conjunto de conteúdos terminais possíveis e faz a criação de um nó terminal. Essa função, de uso interno, serve para criar um nó terminal com o tratamento do ERC.\n\n_create_random_terminal(tSet::Vector{Union{Var, WeightedVar, Const, ERC}})::TerminalNode\n\nA criação de um nó terminal envolve um passo de verificação adicional para o caso de ERC, que deve substituir o nó por uma constante dentro do intervalo especificado. \n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}","page":"Population initialization","title":"GP_NLS.full","text":"Função que cria uma árvore pelo método full, inspirado no trabalho original de Koza. Recebe um conjunto de funções  fSet::Vector{Func} que serão sorteadas para os nós internos, um conjunto de funções tSet::Vector{Union{Var, WeightedVar, Const, ERC}} que serão utilizadas nos  terminais, e uma profundidade máxima maxDepth::Int64 permitida. Retorna uma árvore qualquer com profundidade máxima maxDepth e utilizando os conteúdos de funções e terminais passados.\n\nfull(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, maxDepth::Int64)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}","page":"Population initialization","title":"GP_NLS.grow","text":"Função que cria uma árvore pelo método grow, inspirado no trabalho original de Koza. Recebe um conjunto de funções  fSet::Vector{Func} que serão sorteadas para os nós internos, um conjunto de funções tSet::Vector{Union{Var, WeightedVar, Const, ERC}} que serão utilizadas nos terminais, e uma profundidade máxima maxDepth::Int64 permitida. Retorna uma árvore qualquer com profundidade máxima maxDepth e utilizando os conteúdos de funções e terminais passados.\n\ngrow(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, maxDepth::Int64)::AbstractNode\n\nRepare que não há tamanho mínimo, significando que pode ser retornada uma árvore de um único nó. A profundidade máxima considera variáveis com peso como um único nó.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Population initialization","title":"GP_NLS.init_pop_PTC2","text":"Função que inicializa uma população de tamanho popSize utilizando o método PTC2.\n\ninit_pop_PTC2(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nTodas as funções de inicialização recebem os mesmos parâmetros, mas nem todas fazem uso de todos eles. Isso é apenas para unificar a chamada da criação de populações\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Population initialization","title":"GP_NLS.init_pop_full","text":"Função que inicializa uma população de tamanho popSize utilizando o método full.\n\ninit_pop_full(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nTodas as funções de inicialização recebem os mesmos parâmetros, mas nem todas fazem uso de todos eles. Isso é apenas para unificar a chamada da criação de populações\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Population initialization","title":"GP_NLS.init_pop_grow","text":"Função que inicializa uma população de tamanho popSize utilizando o método grow.\n\ninit_pop_grow(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nTodas as funções de inicialização recebem os mesmos parâmetros, mas nem todas fazem uso de todos eles. Isso é apenas para unificar a chamada da criação de populações\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_ramped-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Population initialization","title":"GP_NLS.init_pop_ramped","text":"Função que inicializa uma população de tamanho popSize utilizando o método ramped half-half.\n\ninit_pop_ramped(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)\n\nTodas as funções de inicialização recebem os mesmos parâmetros, mas nem todas fazem uso de todos eles. Isso é apenas para unificar a chamada da criação de populações\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#Índice","page":"Population initialization","title":"Índice","text":"","category":"section"},{"location":"Initialization/","page":"Population initialization","title":"Population initialization","text":"","category":"page"},{"location":"Evaluation/#Avaliação-de-árvores","page":"Tree evaluation","title":"Avaliação de árvores","text":"","category":"section"},{"location":"Evaluation/","page":"Tree evaluation","title":"Tree evaluation","text":"Funções que fazem a avaliação de uma árvore para um conjunto de dados e calculam seu fitness.","category":"page"},{"location":"Evaluation/#Tipos-e-Funções","page":"Tree evaluation","title":"Tipos e Funções","text":"","category":"section"},{"location":"Evaluation/","page":"Tree evaluation","title":"Tree evaluation","text":"Modules = [GP_NLS]\r\nPages   = [\"Evaluation.jl\"]","category":"page"},{"location":"Evaluation/#GP_NLS.evaluate-Tuple{GP_NLS.TerminalNode,Array{Float64,2}}","page":"Tree evaluation","title":"GP_NLS.evaluate","text":"Function that takes any node of a tree (AbstractNode), and an data matrix X (where each row is an observation and each column is a variable), and evaluate the prediction for each observation in X. The function makes a recursive call along the tree node and evaluates the expression using the matrix variable columns that exist in the tree.\n\nIf the node is a InternalNode, the recursive call is made with its children and the result is used as arguments of the node function.\n\nIf it is a TerminalNode with content Const, a vector with size(X, 1) repeatedly containing the constant is returned.\n\nIf it is a TerminalNode with content Var or WeightedVar, the column of the index Var.var_idx of X will be used to extract  the value of the variable from the matrix.\n\nevaluate(node::Union{TerminalNode, InternalNode}, X::Matrix{Float64})::Vector{Float64}\n\nImplements a multiple dispatch for the case of TerminalNode and InternalNode.\n\n\n\n\n\n","category":"method"},{"location":"Evaluation/#GP_NLS.fitness-Tuple{GP_NLS.AbstractNode,Array{Float64,2},Array{Float64,1}}","page":"Tree evaluation","title":"GP_NLS.fitness","text":"Function that measures the fitness of a given tree, in relation to an training data matrix X::Matrix{Float64} and a vector of expected results y::Vector{Float64}.\n\nfitness(tree::AbstractNode, X::Matrix{Float64}, y::Vector{Float64})::Float64\n\nThe fitness is calculated using the RMSE, and this method returns an infinite fitness if the tree fails to evaluate –- forcing the selective pressure to likely eliminate the individual from the population without having to think about protected operations.\n\n\n\n\n\n","category":"method"},{"location":"Evaluation/#Índice","page":"Tree evaluation","title":"Índice","text":"","category":"section"},{"location":"Evaluation/","page":"Tree evaluation","title":"Tree evaluation","text":"","category":"page"},{"location":"Nodes/#Conteúdo-dos-nós-das-árvores","page":"Node contents","title":"Conteúdo dos nós das árvores","text":"","category":"section"},{"location":"Nodes/","page":"Node contents","title":"Node contents","text":"Toda a representação por árvores começa aqui. Essas Structs são utilizadas como conteúdo dos nós da árvore (e não como nós diretos).","category":"page"},{"location":"Nodes/#Tipos-e-Funções","page":"Node contents","title":"Tipos e Funções","text":"","category":"section"},{"location":"Nodes/","page":"Node contents","title":"Node contents","text":"Modules = [GP_NLS]\r\nPages   = [\"NodeContent.jl\"]","category":"page"},{"location":"Nodes/#GP_NLS.defaultConstSet","page":"Node contents","title":"GP_NLS.defaultConstSet","text":"Default const set\n\nConst(3.1415),\nConst(1.0),\nConst(-1.0)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.defaultERCSet","page":"Node contents","title":"GP_NLS.defaultERCSet","text":"Default ERC set\n\nERC(-1.0, 1.0)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.defaultFunctionSet","page":"Node contents","title":"GP_NLS.defaultFunctionSet","text":"Default functions set\n\nFunc(+, 2),\nFunc(-, 2),\nFunc(myprod, 2),\nFunc(mydiv, 2),\n\nFunc(mysquare, 1),\nFunc(mysqrt, 1),\nFunc(myexp, 1),\nFunc(mylog, 1)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.Const","page":"Node contents","title":"GP_NLS.Const","text":"Struct to be the content of an terminal node of an expression tree. This struct represents a Float64 constant value.\n\nConst(v::Float64)\n\nReceives a Float64 value v which will be used as a constant.\n\nThe representation of the constant as string is obtained by rounding the value to 3 decimal places, and it is automatically obtained.\n\nWhen using non-linear optimization, the nonlinear least squares optimization method looks for this struct specifically to optimize their values.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.ERC","page":"Node contents","title":"GP_NLS.ERC","text":"Struct to be the content of an terminal node of an expression tree. This struct keeps the range limits for creating a random constant with the ERC method.\n\nERC(lb::Float64, ub::Float64)\n\nThis struct is used to create constants in the terminal nodes. When it is selected to be a terminal, a new terminal will be created with the struct Const with a random value drawn between [lb, ub) to take the place of the ERC (Ephemeral Random Constant) at the terminal node. The string representation of the created constant is as described in Const documentation.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.Func","page":"Node contents","title":"GP_NLS.Func","text":"Struct to be the content of an internal node of an expression tree.\n\nFunc(f::Function, a::Int64)\n\nTakes a function f and the arity a of the function. The function must always work in vectorized form (will always receive a arrays with n values, where each value of the array is an observation). So the function input will have a rows and n columns when this node is being evaluated in other methods.\n\nThe function's representation as a string is inferred from the name of the function passed, and when this node is used to create a node of a tree, it will have a children.\n\nWhen creating new functions, protected operators must not be used. The  non-linear optimization method uses autodiff to differentiate the tree, and complex functions can be problematic to automatically differentiate.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.Var","page":"Node contents","title":"GP_NLS.Var","text":"Struct to be the content of a terminal node of an expression tree. This struct represents a variable of the data set.\n\nVar(v::String, i::Int64)\n\nReceives a string v that will be used as the representation of the variable when printing the expression (you can use a placeholder if the database do not have column names) and a ì index that matches the column index of the corresponding variable in the observations.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.WeightedVar","page":"Node contents","title":"GP_NLS.WeightedVar","text":"Struct to be the content of a terminal node of an expression tree. This struct represents a weighted variable, that have a coefficient associated with it at the time of creation.\n\nWeightedVar(v::String, i::Int64)\n\nThis struct represents a weighted variable, that can be adjusted with  the non-linear least squares method.\n\nThe String representation is inferred as the same way when creating a Var and the coefficient is inferred in the same way as a Const.\n\nWeightedVar(v::String, i::Int64, w::Float64)\n\nAdditionally, you can force a specific coefficient by passing the value as the third argument on the constructor. When no value is specified, the coefficient is set to 1.0.\n\nThis weighted variable is a subtree with 3 nodes and depth 2, but in practice it is treated as a single node, as it is not of interest to make the dissociation between the weight and the variable during the GP process. By treating the weighted variable as a single node, it is not necessary to modify the crossover or mutation implementations to prevent changing the subtree.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#Índice","page":"Node contents","title":"Índice","text":"","category":"section"},{"location":"Nodes/","page":"Node contents","title":"Node contents","text":"","category":"page"},{"location":"Trees/#Estrutura-das-árvores","page":"Tree structures","title":"Estrutura das árvores","text":"","category":"section"},{"location":"Trees/","page":"Tree structures","title":"Tree structures","text":"Para construir as árvores de expressões, são utilizadas as structs definidas aqui, que funcionam como um esqueleto das árvores.","category":"page"},{"location":"Trees/#Tipos-e-Funções","page":"Tree structures","title":"Tipos e Funções","text":"","category":"section"},{"location":"Trees/","page":"Tree structures","title":"Tree structures","text":"Modules = [GP_NLS]\r\nPages   = [\"TreeStructure.jl\"]","category":"page"},{"location":"Trees/#GP_NLS.AbstractNode","page":"Tree structures","title":"GP_NLS.AbstractNode","text":"Abstract type of our symbolic tree nodes. The idea of creating this type is to create subtypes InternalNode and TerminalNode, and then use multiple dispatch to implement functions that should have different behavior when manipulating the expression trees.\n\nExpression trees should not be built using Var, WeightedVar, Const, Func, ERC, but with these nodes, which  are intended to be used as the \"backbone\" of the tree. The backbone is build using the InternalNode and TerminalNode, and its contents should be the ones declared in NodeContentjl.\n\nA terminal node must have as its contents only the types Const, Var, WeightedVar, and an internal nodemust have its contents the type Func.\n\nNotice that the ERC, when selected to be used in a terminal during the creation of a tree, is replaced by a random Const node). There are not any explicit ERC terminal in the trees.\n\n\n\n\n\n","category":"type"},{"location":"Trees/#GP_NLS.InternalNode","page":"Tree structures","title":"GP_NLS.InternalNode","text":"Struct to build the internal nodes of the backbone of the tree. Its contents will always be of the func type, a f ::Func function that will necessarily have f.arity children, where f.arity is the arity of the function.\n\nInternalNode(f::Func, children::Vector{AbstractNode}) <: AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"Trees/#GP_NLS.TerminalNode","page":"Tree structures","title":"GP_NLS.TerminalNode","text":"Struct to build the terminal nodes of the backbone of the tree. Its contents will always be of the terminal type: Union{Const, Var, WeightedVar}.\n\nTerminalNode(terminal::Union{Const, Var, WeightedVar}) <: AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"Trees/#Índice","page":"Tree structures","title":"Índice","text":"","category":"section"},{"location":"Trees/","page":"Tree structures","title":"Tree structures","text":"","category":"page"},{"location":"LsqOptimization/#Otimização-não-linear-de-coeficientes","page":"Non-linear optimization","title":"Otimização não linear de coeficientes","text":"","category":"section"},{"location":"LsqOptimization/","page":"Non-linear optimization","title":"Non-linear optimization","text":"Implementação de funções auxiliares e do método de otimização não-linear de coeficientes. Todas as funções declaradas aqui são de uso interno da  biblioteca.","category":"page"},{"location":"LsqOptimization/#Tipos-e-Funções","page":"Non-linear optimization","title":"Tipos e Funções","text":"","category":"section"},{"location":"LsqOptimization/","page":"Non-linear optimization","title":"Non-linear optimization","text":"Modules = [GP_NLS]\r\nPages   = [\"Evolutionary.jl\"]","category":"page"},{"location":"LsqOptimization/#Índice","page":"Non-linear optimization","title":"Índice","text":"","category":"section"},{"location":"LsqOptimization/","page":"Non-linear optimization","title":"Non-linear optimization","text":"","category":"page"},{"location":"Exported/#Estrutura-das-árvores","page":"Types and functions exported","title":"Estrutura das árvores","text":"","category":"section"},{"location":"Exported/","page":"Types and functions exported","title":"Types and functions exported","text":"Para construir as árvores de expressões, são utilizadas as structs definidas aqui, que funcionam como um esqueleto das árvores.","category":"page"},{"location":"Exported/#Tipos","page":"Types and functions exported","title":"Tipos","text":"","category":"section"},{"location":"Exported/","page":"Types and functions exported","title":"Types and functions exported","text":"Func\nConst\nVar\nWeightedVar\nERC      ","category":"page"},{"location":"Exported/#Conjuntos-padrões","page":"Types and functions exported","title":"Conjuntos padrões","text":"","category":"section"},{"location":"Exported/","page":"Types and functions exported","title":"Types and functions exported","text":"defaultFunctionSet\ndefaultConstSet\ndefaultERCSet     ","category":"page"},{"location":"Exported/#Funções-auxiliares","page":"Types and functions exported","title":"Funções auxiliares","text":"","category":"section"},{"location":"Exported/","page":"Types and functions exported","title":"Types and functions exported","text":"evaluate\ngetstring\nnumberofnodes\ndepth\ntrue_numberofnodes\ntrue_depth        ","category":"page"},{"location":"Exported/#Algoritmo-evolutivo","page":"Types and functions exported","title":"Algoritmo evolutivo","text":"","category":"section"},{"location":"Exported/","page":"Types and functions exported","title":"Types and functions exported","text":"GP\nfitness","category":"page"},{"location":"Exported/#Índice","page":"Types and functions exported","title":"Índice","text":"","category":"section"},{"location":"Exported/","page":"Types and functions exported","title":"Types and functions exported","text":"","category":"page"},{"location":"Utils/#Funções-de-utilidade","page":"Utility functions","title":"Funções de utilidade","text":"","category":"section"},{"location":"Utils/","page":"Utility functions","title":"Utility functions","text":"Implementação de algumas funções auxiliares que são utilizadas  para inspecionar e manipular as árvores de forma mais geral.","category":"page"},{"location":"Utils/#Tipos-e-Funções","page":"Utility functions","title":"Tipos e Funções","text":"","category":"section"},{"location":"Utils/","page":"Utility functions","title":"Utility functions","text":"Modules = [GP_NLS]\r\nPages   = [\"Utils.jl\"]","category":"page"},{"location":"Utils/#GP_NLS.branches_in_limits","page":"Utility functions","title":"GP_NLS.branches_in_limits","text":"Finds all branches of any tree node that have a number of nodes less than or equal to allowedSize and a depth less than or equal to allowedDepth . Returns a list with the position of all branches found.\n\nbranches_in_limits(\n    allowedSize::Int64, allowedDepth::Int64, node::AbstractNode, _point::Int64=1)::Vector{Int64}\n\nThe _point parameter being returned is for internal use, and serves to monitor the point of the tree where the candidates were found. This is only meaningful to recursive calls, and outside of the function it does not represent any useful information.\n\n\n\n\n\n","category":"function"},{"location":"Utils/#GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}","page":"Utility functions","title":"GP_NLS.change_at!","text":"Takes a point p of type integer (which must be less than or equal to the number of nodes of branch), a branch of type AbstractNode, and any node AbstractNode representing a tree. Returns a modification of the tree by inserting the branch into the tree at position `p. This function changes the tree passed as argument.\n\nchange_at!(p::Int64, branch::AbstractNode, node::AbstractNode)::AbstractNode\n\nThis method is mainly used to modify trees in the crossover operation.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}","page":"Utility functions","title":"GP_NLS.change_children!","text":"Function that takes a point p (which must be less than or equal to the number of nodes of branch), a branch of type AbstractNode, and a list of children Vector{AbstractNode}. Returns a modification of the list of children, where the p position node will be replaced by the given branch. This function changes the list of children passed as argument.\n\nchange_children!(p::Int64, branch::AbstractNode, children::Vector{AbstractNode})::Vector{AbstractNode}\n\nThis function is a helper to change_at!, and itsfor internal use. It is not exported by the module.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.copy_tree","text":"Function that takes any node of a tree (AbstractNode) and recursively recreates the structure so that references are not shared between the tree passed and the tree returned, avoiding side effects when manipulating the tree.\n\ncopy_tree(node::AbstractNode)::TerminalNode\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.depth-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.depth","text":"Function that takes any node of a tree (AbstractNode) and recursively finds the depth of the tree, where the depth is the size of its largest branch. This depth function does not take into count the coefficients of weighted variables (which are, in fact, a subtree with depth 2). To find the depth of a tree considering weighted variables as a subtree (and not as a single node), use the function true_depth.\n\ndepth(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}","page":"Utility functions","title":"GP_NLS.get_branch_at","text":"Function that takes any node of a tree (AbstractNode) and an integer p (which must be less than or equal to the number of nodes in tree) and returns the branch at position p.\n\nget_branch_at(p::Int64, node::AbstractNode)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}","page":"Utility functions","title":"GP_NLS.get_depth_at","text":"Takes a point p of type integer (which must be less than or equal to the number of nodes of the node passed) and any node AbstractNode representing a tree, then this function find and return the depth of the subtree at position p.\n\nget_depth_at(p::Int64, node::AbstractNode)::Int64\n\nIt's almost like finding the depth of the tree, but when we are interested  in finding the depth of a subtree that is at the point p, not the whole tree depth.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.getstring-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.getstring","text":"Function that takes any node of a tree (AbstractNode) and recursively builds a string representation of the tree, where functions are always denoted in prefixed notation, with arguments in parentheses.\n\ngetstring(node::AbstractNode)::String\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.numberofnodes-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.numberofnodes","text":"Function that takes any node of a tree (AbstractNode) and recursively counts the total number of nodes of the tree. This function counts weighted variables as a single node. To find the number of nodes of a tree considering weighted variables as a subtree (and not as a single node), use the function true_numberofnodes.\n\nnumberofnodes(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.true_depth-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.true_depth","text":"Function that takes any node of a tree (AbstractNode) and recursively finds the depth of the tree, where the depth is the size of its largest branch. This depth function returns a value that corresponds to the number of existing nodes in the tree, considering weighted variables as being a subtree of depth 2. This function is not used in implementations, and is available to users who want to get the real depth of GP-NLS trees.\n\ntrue_depth(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.true_numberofnodes-Tuple{GP_NLS.TerminalNode}","page":"Utility functions","title":"GP_NLS.true_numberofnodes","text":"Function that takes any node of a tree (AbstractNode) and recursively counts the total number of nodes of the tree. This function counts weighted  variables as three nodes. This function is only used in mutate, crossover, and initialize operations to avoid creating trees larger than the allowed.\n\ntrue_numberofnodes(node::AbstractNode)::Int64\n\nThis function works by having a multiple dispatch for each subtype of AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}","page":"Utility functions","title":"GP_NLS.which_children","text":"Function that takes a set of children of the same node as the array children::Vector{AbstractNode}, and an integer p (which must be less than or equal to number of nodes in children) and finds the child containing the p-th node of the children if it was traversed inorder.\n\nReturns a tuple containing the child which contains the node of index p, and an integer informing the position of the p-th node within the returned (child) subtree.\n\nwhich_children(p::Int64, children::Vector{AbstractNode})::Tuple{Int64, AbstractNode}\n\n\n\n\n\n","category":"method"},{"location":"Utils/#Índice","page":"Utility functions","title":"Índice","text":"","category":"section"},{"location":"Utils/","page":"Utility functions","title":"Utility functions","text":"","category":"page"}]
}
