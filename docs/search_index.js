var documenterSearchIndex = {"docs":
[{"location":"#Documentação-de-GP_NLS","page":"Documentação de GP_NLS","title":"Documentação de GP_NLS","text":"","category":"section"},{"location":"","page":"Documentação de GP_NLS","title":"Documentação de GP_NLS","text":"Implementação de um algoritmo de regressão simbólica com representação por árvores e possibilidade de uso de um método de otimização não linear para ajuste dos coeficientes.","category":"page"},{"location":"#Sobre","page":"Documentação de GP_NLS","title":"Sobre","text":"","category":"section"},{"location":"","page":"Documentação de GP_NLS","title":"Documentação de GP_NLS","text":"Essa biblioteca foi desenvolvida como projeto na disciplina Computação Bio-inspirada, ministrada pelo Prof. Dr. Fabrício Olivetti de França pelo Programa de Pós Graduação em Ciência da Computação da Universidade Federal do ABC (PPGCM, UFABC).","category":"page"},{"location":"","page":"Documentação de GP_NLS","title":"Documentação de GP_NLS","text":"A implementação foi feita de forma que seja possível utilizar diferentes formas de inicializar e tratar os coeficientes na representação por árvores.","category":"page"},{"location":"#Funções-visíveis-pelo-import","page":"Documentação de GP_NLS","title":"Funções visíveis pelo import","text":"","category":"section"},{"location":"","page":"Documentação de GP_NLS","title":"Documentação de GP_NLS","text":"As funções que são de fato exportadas estão indicadas na barra de navegação.","category":"page"},{"location":"#Funções-internas","page":"Documentação de GP_NLS","title":"Funções internas","text":"","category":"section"},{"location":"","page":"Documentação de GP_NLS","title":"Documentação de GP_NLS","text":"A biblioteca conta com algumas funções internas auxiliares que seu uso não é recomendado. Todas as implementações encontram-se listadas nos módulos da  biblioteca, mas apenas algumas são exportadas para fora do pacote.","category":"page"},{"location":"Evolutionary/#Algoritmo-evolutivo","page":"Algoritmo evolutivo","title":"Algoritmo evolutivo","text":"","category":"section"},{"location":"Evolutionary/","page":"Algoritmo evolutivo","title":"Algoritmo evolutivo","text":"Implementação da mutação, crossover e GP.","category":"page"},{"location":"Evolutionary/#Tipos-e-Funções","page":"Algoritmo evolutivo","title":"Tipos e Funções","text":"","category":"section"},{"location":"Evolutionary/","page":"Algoritmo evolutivo","title":"Algoritmo evolutivo","text":"Modules = [GP_NLS]\r\nPages   = [\"Evolutionary.jl\"]","category":"page"},{"location":"Evolutionary/#GP_NLS.GP","page":"Algoritmo evolutivo","title":"GP_NLS.GP","text":"GP Com controle de profundidade e número de nós. A inicialização recomendada é a PTC2, mas temos as outras também (entretanto, os outros métodos são baseados no GP do koza e não seguem restrição de número máximo de nós).\n\nGP(\n    X::Matrix{Float64}, \n    y::Vector{Float64},\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    minDepth::Int64        = 1,\n    maxDepth::Int64        = 5,\n    maxSize::Int64         = 25,\n    popSize::Int64         = 50,\n    gens::Int64            = 50,\n    mutationRate::Float64  = 0.25,\n    elitism::Bool          = false,\n    verbose::Bool          = false,\n    init_method::String    = \"PTC2\", #[\"ramped\", \"grow\", \"full\", \"PTC2\"]\n    lm_optimization        = false, \n    keep_linear_transf_box = false\n)::AbstractNode\n\n\n\n\n\n","category":"function"},{"location":"Evolutionary/#GP_NLS.crossover-Tuple{GP_NLS.AbstractNode,GP_NLS.AbstractNode,Int64,Int64}","page":"Algoritmo evolutivo","title":"GP_NLS.crossover","text":"Função de crossover que faz uma recombinação dos dois pais passados como argumento, encontrando um ponto de quebra em cada uma das árvores pais e trocando a subárvore entre esses pontos. Não modifica os pais. Esse crossover controla o número de nós (e não a profundidade).\n\ncrossover(\n    fst_parent::AbstractNode,\n    snd_parent::AbstractNode,\n    maxDepth::Int64,\n    maxSize::Int64)::AbstractNode\n\nQueremos que o crossover ocorra em um ponto de corte que não causa o aumento da árvore filha para algo maior que o limite.\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#GP_NLS.mutation!-Tuple{GP_NLS.AbstractNode,Int64,Int64,Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Float64}","page":"Algoritmo evolutivo","title":"GP_NLS.mutation!","text":"Função que implementa uma mutação tradicional de substituição em uma árvore, respeitando a  profundidade máxima passada. Modifica a árvore passada.\n\nmutation!(\n    node::AbstractNode,\n    maxDepth::Int64,\n    maxSize::Int64,\n    fSet::Vector{Func},\n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}},\n    mutationRate::Float64\n)::AbstractNode\n\nA taxa de mutação mutationRate deve variar em 0 1 e determina a chance de ocorrer uma mutação (substituindo um ponto aleatório por uma nova sub-árvore) ou o próprio nó passado ser retornado.\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#GP_NLS.tourn_selection-Tuple{Tuple{GP_NLS.AbstractNode,Float64},Tuple{GP_NLS.AbstractNode,Float64}}","page":"Algoritmo evolutivo","title":"GP_NLS.tourn_selection","text":"Função que recebe dois indivíduos e faz uma seleção por torneio simples. Um indivíduo é uma tupla (fitness::Float64, node::AbstractNode) com a árvore e seu fitness, para evitar que seja recalculado a todo instante.\n\ntourn_selection(ind1::Tuple{Float64, AbstractNode}, ind2::Tuple{Float64, AbstractNode})::Tuple{AbstractNode, Float64}\n\nO retorno é uma tupla com o indivíduo vencedor (ou seja, é retornada uma tupla).\n\n\n\n\n\n","category":"method"},{"location":"Evolutionary/#Índice","page":"Algoritmo evolutivo","title":"Índice","text":"","category":"section"},{"location":"Evolutionary/","page":"Algoritmo evolutivo","title":"Algoritmo evolutivo","text":"","category":"page"},{"location":"Initialization/#Inicialização-da-população","page":"Inicialização de população","title":"Inicialização da população","text":"","category":"section"},{"location":"Initialization/","page":"Inicialização de população","title":"Inicialização de população","text":"Implementação de diferentes funções para criar árvores, e funções que criam uma população inteira","category":"page"},{"location":"Initialization/#Tipos-e-Funções","page":"Inicialização de população","title":"Tipos e Funções","text":"","category":"section"},{"location":"Initialization/","page":"Inicialização de população","title":"Inicialização de população","text":"Modules = [GP_NLS]\r\nPages   = [\"Initialization.jl\"]","category":"page"},{"location":"Initialization/#GP_NLS.PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64}","page":"Inicialização de população","title":"GP_NLS.PTC2","text":"Criação de árvores com o método Probabilistic Tree Creator 2 (PTC2), descrito em Two Fast Tree-Creation Algorithms for Genetic Programming, de Sean Luke.\n\nEsse método se parece com o método full de Koza, mas além de respeitar um limite de  profundidade maxDepth, respeita um limite de quantidade de nós expctdSize. O PTC2 garante que a profundidade não ultrapasse o máximo (no nosso caso, variáveis com peso contam como profundidade 1), e garante que o número de nós não ultrapasse o valor esperado somado da maior aridade entre as funções, isso é, expctdSize + max(aridade(f)) f in fSet.\n\nPTC2(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    maxDepth::Int64,\n    expctdSize::Int64)::AbstractNode\n\nAqui adotamos que a chance de selecionar um terminal t quando for necessário inserir um terminal será uniforme para todos os terminais, e a chance de inserir uma função  também seguirá a mesma lógica.\n\nO algoritmo do PTC2 é descrito em C e faz o uso de pilhas e ponteiros. Em Julia, não há todos esses recursos de forma simples, e uma adaptação dessas funções foi feita.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS._create_random_terminal-Tuple{Array{Union{ERC, Const, Var, WeightedVar},1}}","page":"Inicialização de população","title":"GP_NLS._create_random_terminal","text":"Função que recebe o conjunto de conteúdos terminais possíveis e faz a criação de um nó terminal. Essa função, de uso interno, serve para criar um nó terminal com o tratamento do ERC.\n\n_create_random_terminal(tSet::Vector{Union{Var, WeightedVar, Const, ERC}})::TerminalNode\n\nA criação de um nó terminal envolve um passo de verificação adicional para o caso de ERC, que deve substituir o nó por uma constante dentro do intervalo especificado. \n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}","page":"Inicialização de população","title":"GP_NLS.full","text":"Função que cria uma árvore pelo método full, inspirado no trabalho original de Koza. Recebe um conjunto de funções  fSet::Vector{Func} que serão sorteadas para os nós internos, um conjunto de funções tSet::Vector{Union{Var, WeightedVar, Const, ERC}} que serão utilizadas nos  terminais, e uma profundidade máxima maxDepth::Int64 permitida. Retorna uma árvore qualquer com profundidade máxima maxDepth e utilizando os conteúdos de funções e terminais passados.\n\nfull(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, maxDepth::Int64)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}","page":"Inicialização de população","title":"GP_NLS.grow","text":"Função que cria uma árvore pelo método grow, inspirado no trabalho original de Koza. Recebe um conjunto de funções  fSet::Vector{Func} que serão sorteadas para os nós internos, um conjunto de funções tSet::Vector{Union{Var, WeightedVar, Const, ERC}} que serão utilizadas nos terminais, e uma profundidade máxima maxDepth::Int64 permitida. Retorna uma árvore qualquer com profundidade máxima maxDepth e utilizando os conteúdos de funções e terminais passados.\n\ngrow(fSet::Vector{Func}, tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, maxDepth::Int64)::AbstractNode\n\nRepare que não há tamanho mínimo, significando que pode ser retornada uma árvore de um único nó. A profundidade máxima considera variáveis com peso como um único nó.\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Inicialização de população","title":"GP_NLS.init_pop_PTC2","text":"Função que inicializa uma população de tamanho popSize utilizando o método PTC2.\n\ninit_pop_PTC2(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nTodas as funções de inicialização recebem os mesmos parâmetros, mas nem todas fazem uso de todos eles. Isso é apenas para unificar a chamada da criação de populações\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Inicialização de população","title":"GP_NLS.init_pop_full","text":"Função que inicializa uma população de tamanho popSize utilizando o método full.\n\ninit_pop_full(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nTodas as funções de inicialização recebem os mesmos parâmetros, mas nem todas fazem uso de todos eles. Isso é apenas para unificar a chamada da criação de populações\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Inicialização de população","title":"GP_NLS.init_pop_grow","text":"Função que inicializa uma população de tamanho popSize utilizando o método grow.\n\ninit_pop_grow(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)::Vector{AbstractNode}\n\nTodas as funções de inicialização recebem os mesmos parâmetros, mas nem todas fazem uso de todos eles. Isso é apenas para unificar a chamada da criação de populações\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#GP_NLS.init_pop_ramped-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}","page":"Inicialização de população","title":"GP_NLS.init_pop_ramped","text":"Função que inicializa uma população de tamanho popSize utilizando o método ramped half-half.\n\ninit_pop_ramped(\n    fSet::Vector{Func}, \n    tSet::Vector{Union{Var, WeightedVar, Const, ERC}}, \n    minDepth::Int64,\n    maxDepth::Int64,\n    expctdSize::Int64,\n    popSize::Int64)\n\nTodas as funções de inicialização recebem os mesmos parâmetros, mas nem todas fazem uso de todos eles. Isso é apenas para unificar a chamada da criação de populações\n\n\n\n\n\n","category":"method"},{"location":"Initialization/#Índice","page":"Inicialização de população","title":"Índice","text":"","category":"section"},{"location":"Initialization/","page":"Inicialização de população","title":"Inicialização de população","text":"","category":"page"},{"location":"Evaluation/#Avaliação-de-árvores","page":"Avaliação de árvores","title":"Avaliação de árvores","text":"","category":"section"},{"location":"Evaluation/","page":"Avaliação de árvores","title":"Avaliação de árvores","text":"Funções que fazem a avaliação de uma árvore para um conjunto de dados e calculam seu fitness.","category":"page"},{"location":"Evaluation/#Tipos-e-Funções","page":"Avaliação de árvores","title":"Tipos e Funções","text":"","category":"section"},{"location":"Evaluation/","page":"Avaliação de árvores","title":"Avaliação de árvores","text":"Modules = [GP_NLS]\r\nPages   = [\"Evaluation.jl\"]","category":"page"},{"location":"Evaluation/#GP_NLS.evaluate-Tuple{GP_NLS.TerminalNode,Array{Float64,2}}","page":"Avaliação de árvores","title":"GP_NLS.evaluate","text":"Função que recebe um nó qualquer de uma árvore (AbstractNode), e implementa um despache múltiplo para o caso de TerminalNode e InternalNode, e  uma matriz de dados X. Função para avaliar uma base de dados utilizando a árvore passada.\n\nevaluate(node::Union{TerminalNode, InternalNode}, X::Matrix{Float64})::Vector{Float64}\n\nA função faz uma chamada recursiva ao longo do nó passado e avalia a expressão utilizando as colunas de variáveis da matriz que existem na árvore.\n\nCaso o nó seja uma função, a chamada recursiva é feita com seus filhos e o resultado é utilizado como argumentos na função. Caso seja uma constante, um vetor com  size(X, 1) contendo repetidas vezes a constante é retornado. Caso seja uma variável, a coluna de X de mesmo índice Var.var_idx será utilizado para extrair um vetor da matriz.\n\n\n\n\n\n","category":"method"},{"location":"Evaluation/#GP_NLS.fitness-Tuple{GP_NLS.AbstractNode,Array{Float64,2},Array{Float64,1}}","page":"Avaliação de árvores","title":"GP_NLS.fitness","text":"Função que mede o fitness de uma árvore qualquer, em relação a uma matriz de observações X::Matrix{Float64} e um vetor de resultados esperados y::Vector{Float64}.\n\nfitness(tree::AbstractNode, X::Matrix{Float64}, y::Vector{Float64})::Float64\n\nO fitness é calculado utilizando o RMSE, e esse método retorna um fitness infinito caso a árvore falhe em avaliar –- fazendo com que a pressão seletiva seja forte e provavelmente elimine o indivíduo da população sem ter que pensar em operações protegidas, o que é particularmente interessante por não aumentar a complexidade das funções dos nós, já que é feito o uso de um autodiff para diferenciar a árvore, e pode ser problemático diferenciar funções com IFS ou cálculos mais elaborados.\n\n\n\n\n\n","category":"method"},{"location":"Evaluation/#Índice","page":"Avaliação de árvores","title":"Índice","text":"","category":"section"},{"location":"Evaluation/","page":"Avaliação de árvores","title":"Avaliação de árvores","text":"","category":"page"},{"location":"Nodes/#Conteúdo-dos-nós-das-árvores","page":"Conteúdos dos nós","title":"Conteúdo dos nós das árvores","text":"","category":"section"},{"location":"Nodes/","page":"Conteúdos dos nós","title":"Conteúdos dos nós","text":"Toda a representação por árvores começa aqui. Essas Structs são utilizadas como conteúdo dos nós da árvore (e não como nós diretos).","category":"page"},{"location":"Nodes/#Tipos-e-Funções","page":"Conteúdos dos nós","title":"Tipos e Funções","text":"","category":"section"},{"location":"Nodes/","page":"Conteúdos dos nós","title":"Conteúdos dos nós","text":"Modules = [GP_NLS]\r\nPages   = [\"Nodes.jl\"]","category":"page"},{"location":"Nodes/#GP_NLS.defaultConstSet","page":"Conteúdos dos nós","title":"GP_NLS.defaultConstSet","text":"Conjunto de constantes padrão\n\nConst(3.1415),\nConst(1.0),\nConst(-1.0)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.defaultERCSet","page":"Conteúdos dos nós","title":"GP_NLS.defaultERCSet","text":"Conjunto de ERC padrão\n\nERC(-1.0, 1.0)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.defaultFunctionSet","page":"Conteúdos dos nós","title":"GP_NLS.defaultFunctionSet","text":"Conjunto de funções padrão\n\nFunc(+, 2),\nFunc(-, 2),\nFunc(myprod, 2),\nFunc(mydiv, 2),\n\nFunc(mysquare, 1),\nFunc(mysqrt, 1),\nFunc(myexp, 1),\nFunc(mylog, 1)\n\n\n\n\n\n","category":"constant"},{"location":"Nodes/#GP_NLS.Const","page":"Conteúdos dos nós","title":"GP_NLS.Const","text":"Struct para representar um valor Float64 constante nos terminais das árvores. \n\nConst(v::Float64)\n\nRecebe um valor Float64 v que será utilizado como constante.\n\nA representação da constante como string é obtida arredondando o valor  para 3 casas decimais, e é obtida automaticamente\n\nO método de otimização com mínimos quadrados não linear busca por essa struct especificamente para fazer a otimização dos seus valores.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.ERC","page":"Conteúdos dos nós","title":"GP_NLS.ERC","text":"Struct que guarda os limites do intervalo de criação de uma constante aleatória.\n\nERC(lb::Float64, ub::Float64)\n\nEssa struct é utilizada para criação de constantes nos terminais quando é selecionada, sendo que será criado um terminal com a struct Const com um valor aleatório sorteado entre [lb, ub) para ocupar o lugar do ERC (Ephemeral Random Constant) no terminal. A representação em string da constante criada é como descrito na documentação de Const.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.Func","page":"Conteúdos dos nós","title":"GP_NLS.Func","text":"Struct para representar uma função de um nó interno de uma árvore de expressão.\n\nFunc(f::Function, a::Int64)\n\nRecebe uma função f e a aridade da função a. A função deve sempre funcionar na forma vetorizada (receberá sempre a arrays (com n valores, onde cada um é uma observação, sendo cada array um argumento da função) e é aplicada sobre os arrays.  Então a entrada da função terá a linhas e n colunas.\n\nA representação da função em string é inferida do nome da função passada, e quando essa função for utilizada para criar um nó de uma árvore, ela terá a filhos.\n\nNa implementação dessa biblioteca, não devem ser utilizados operadores protegidos, já que é feito o uso de um autodiff para diferenciar a árvore, e pode ser problemático diferenciar funções com IFs ou cálculos mais elaborados para proteger a função.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.Var","page":"Conteúdos dos nós","title":"GP_NLS.Var","text":"Struct que representa uma variável do problema, e é utilizada nos terminais das árvores.\n\nVar(v::String, i::Int64)\n\nRecebe uma string v que será utilizada como representação da variável na hora de imprimir os dados (pode-se utilizar um placeholder caso a base de dados não tenha nome nas colunas) e um índice ì que corresponde ao índice da coluna da variável correspondente na matriz da base de dados.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#GP_NLS.WeightedVar","page":"Conteúdos dos nós","title":"GP_NLS.WeightedVar","text":"Struct de uma variável com coeficiente. Utilizar quando quisermos que as variáveis criadas tenham sempre um coeficiente associado à elas no momento de criação.\n\nWeightedVar(v::String, i::Int64) = new(v, i, v)\n\nEssa struct representa uma variável com peso que pode ser ajustado pelo método de otimização (ou definido antes da execução pelo utilizador, por meio do  múltiplo despache do construtor da struct).\n\nA representação em String é inferida da forma que uma Var em relação ao nome da variável, e o coeficiente é inferido da mesma forma que uma Const.\n\nEssa variável ponderada é, na teoria, uma sub-árvore com 3 nós e profundidade 2, mas na prática é tratada como um único nó pois não é de interesse fazer uma dissociação entre o peso e a variável durante o processo evolutido. Ao tratar a variável com peso como um único nó, não é necessario modificar nenhuma implementação de crossover ou mutação para que não seja destruída essa subárvore.\n\n\n\n\n\n","category":"type"},{"location":"Nodes/#Índice","page":"Conteúdos dos nós","title":"Índice","text":"","category":"section"},{"location":"Nodes/","page":"Conteúdos dos nós","title":"Conteúdos dos nós","text":"","category":"page"},{"location":"Trees/#Estrutura-das-árvores","page":"Estrutura das árvores","title":"Estrutura das árvores","text":"","category":"section"},{"location":"Trees/","page":"Estrutura das árvores","title":"Estrutura das árvores","text":"Para construir as árvores de expressões, são utilizadas as structs definidas aqui, que funcionam como um esqueleto das árvores.","category":"page"},{"location":"Trees/#Tipos-e-Funções","page":"Estrutura das árvores","title":"Tipos e Funções","text":"","category":"section"},{"location":"Trees/","page":"Estrutura das árvores","title":"Estrutura das árvores","text":"Modules = [GP_NLS]\r\nPages   = [\"Trees.jl\"]","category":"page"},{"location":"Trees/#GP_NLS.AbstractNode","page":"Estrutura das árvores","title":"GP_NLS.AbstractNode","text":"Tipo abstrato de nó de árvore. A ideia é fazer esse tipo para deixar claro que InternalNode e TerminalNode são uma derivação desse tipo, e possibilitar assinaturas de funções que independem do tipo específico de nó, mas ainda possibilitar  diferenciar a assinatura quando eles dependem ou tem comportamentos diferentes para cada caso (fazendo uso de despache múltiplo).\n\nAs árvores de expressão não devem ser construídas com Var, WeightedVar, Const, Func, ERC, e sim com esses nós, que são então o esqueleto da árvore, enquanto os anteriores são seus conteúdos. Um nó terminal só pode ter conteúdo Const, Var, WeightedVar, e um nó intermediário só pode ter conteúdo do tipo Func.\n\n(Note que o ERC, ao ser sorteado para ser um terminal, é substituído por uma Const aleatória e então inserido no terminal)\n\n\n\n\n\n","category":"type"},{"location":"Trees/#GP_NLS.InternalNode","page":"Estrutura das árvores","title":"GP_NLS.InternalNode","text":"Struct que forma o esqueleto da árvore, utilizado apenas nos nós internos, para encapsular uma função f :: Func que terá, obrigatóriamente f.arity filhos.\n\nInternalNode(f::Func, children::Vector{AbstractNode}) <: AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"Trees/#GP_NLS.TerminalNode","page":"Estrutura das árvores","title":"GP_NLS.TerminalNode","text":"Struct que forma o esqueleto da árvore, utilizado apenas em nós terminais. É o encapsulamento apenas de Union{Const, Var, WeightedVar}. \n\nTerminalNode(terminal::Union{Const, Var, WeightedVar}) <: AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"Trees/#Índice","page":"Estrutura das árvores","title":"Índice","text":"","category":"section"},{"location":"Trees/","page":"Estrutura das árvores","title":"Estrutura das árvores","text":"","category":"page"},{"location":"LsqOptimization/#Otimização-não-linear-de-coeficientes","page":"Otimização não-linear","title":"Otimização não linear de coeficientes","text":"","category":"section"},{"location":"LsqOptimization/","page":"Otimização não-linear","title":"Otimização não-linear","text":"Implementação de funções auxiliares e do método de otimização não-linear de coeficientes. Todas as funções declaradas aqui são de uso interno da  biblioteca.","category":"page"},{"location":"LsqOptimization/#Tipos-e-Funções","page":"Otimização não-linear","title":"Tipos e Funções","text":"","category":"section"},{"location":"LsqOptimization/","page":"Otimização não-linear","title":"Otimização não-linear","text":"Modules = [GP_NLS]\r\nPages   = [\"Evolutionary.jl\"]","category":"page"},{"location":"LsqOptimization/#Índice","page":"Otimização não-linear","title":"Índice","text":"","category":"section"},{"location":"LsqOptimization/","page":"Otimização não-linear","title":"Otimização não-linear","text":"","category":"page"},{"location":"Exported/#Estrutura-das-árvores","page":"Tipos e funções acessíveis","title":"Estrutura das árvores","text":"","category":"section"},{"location":"Exported/","page":"Tipos e funções acessíveis","title":"Tipos e funções acessíveis","text":"Para construir as árvores de expressões, são utilizadas as structs definidas aqui, que funcionam como um esqueleto das árvores.","category":"page"},{"location":"Exported/#Tipos","page":"Tipos e funções acessíveis","title":"Tipos","text":"","category":"section"},{"location":"Exported/","page":"Tipos e funções acessíveis","title":"Tipos e funções acessíveis","text":"Func\nConst\nVar\nWeightedVar\nERC      ","category":"page"},{"location":"Exported/#Conjuntos-padrões","page":"Tipos e funções acessíveis","title":"Conjuntos padrões","text":"","category":"section"},{"location":"Exported/","page":"Tipos e funções acessíveis","title":"Tipos e funções acessíveis","text":"defaultFunctionSet\ndefaultConstSet\ndefaultERCSet     ","category":"page"},{"location":"Exported/#Funções-auxiliares","page":"Tipos e funções acessíveis","title":"Funções auxiliares","text":"","category":"section"},{"location":"Exported/","page":"Tipos e funções acessíveis","title":"Tipos e funções acessíveis","text":"evaluate\ngetstring\nnumberofnodes\ndepth\ntrue_numberofnodes\ntrue_depth        ","category":"page"},{"location":"Exported/#Algoritmo-evolutivo","page":"Tipos e funções acessíveis","title":"Algoritmo evolutivo","text":"","category":"section"},{"location":"Exported/","page":"Tipos e funções acessíveis","title":"Tipos e funções acessíveis","text":"GP\nfitness","category":"page"},{"location":"Exported/#Índice","page":"Tipos e funções acessíveis","title":"Índice","text":"","category":"section"},{"location":"Exported/","page":"Tipos e funções acessíveis","title":"Tipos e funções acessíveis","text":"","category":"page"},{"location":"Utils/#Funções-de-utilidade","page":"Funções de utilidade","title":"Funções de utilidade","text":"","category":"section"},{"location":"Utils/","page":"Funções de utilidade","title":"Funções de utilidade","text":"Implementação de algumas funções auxiliares que são utilizadas  para inspecionar e manipular as árvores de forma mais geral.","category":"page"},{"location":"Utils/#Tipos-e-Funções","page":"Funções de utilidade","title":"Tipos e Funções","text":"","category":"section"},{"location":"Utils/","page":"Funções de utilidade","title":"Funções de utilidade","text":"Modules = [GP_NLS]\r\nPages   = [\"Utils.jl\"]","category":"page"},{"location":"Utils/#GP_NLS.branches_in_limits","page":"Funções de utilidade","title":"GP_NLS.branches_in_limits","text":"Encontra todos os galhos de uma árvore qualquer node que tem uma quantidade de nós menor ou igual que allowedSize e uma profundidade menor ou igual que allowedDepth . Retorna uma lista com a posição de todos os galhos encontrados.\n\nbranches_in_limits(\n    allowedSize::Int64, allowedDepth::Int64, node::AbstractNode, _point::Int64=1)::Vector{Int64}\n\nO parâmetro _point é de uso interno, e serve para monitorar o ponto da árvore onde foram encontrados os candidatos. Em chamadas recursivas ele faz sentido, mas fora  da função ele não representa nenhuma informação útil.\n\n\n\n\n\n","category":"function"},{"location":"Utils/#GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}","page":"Funções de utilidade","title":"GP_NLS.change_at!","text":"Recebe um ponto p do tipo inteiro (que deve ser menor ou igual ao número de nós da árvore passada), um galho do tipo AbstractNode e um nó qualquer  representando uma árvoreAbstractNode, e insere o galho na árvore passada  no nó de posição p. Altera a árvore passada como argumento.\n\nchange_at!(p::Int64, branch::AbstractNode, node::AbstractNode)::AbstractNode\n\nRecebe um ponto, uma subárvore para inserir, e a árvore onde será inserida. Esse método que realiza a modificação de uma árvore no crossover.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}","page":"Funções de utilidade","title":"GP_NLS.change_children!","text":"Função que recebe um ponto p (que deve ser menor ou igual ao número de nós da árvore passada), um galho do tipo AbstractNode e uma lista de filhos Vector{AbstractNode} e retorna uma modificação da lista de filhos, sendo que o nó de posição p será substituído pelo galho passado. Altera a lista de filhos passada como argumento.\n\nchange_children!(p::Int64, branch::AbstractNode, children::Vector{AbstractNode})::Vector{AbstractNode}\n\nEsse método é auxiliar de change_at! e de uso interno da biblioteca.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}","page":"Funções de utilidade","title":"GP_NLS.copy_tree","text":"Função que recebe um nó qualquer de uma árvore (AbstractNode) e recursivamente recria a estrutura, de forma que as referências não sejam compartilhadas entre a árvore passada e a árvore retornada, evitando efeitos colaterais no manuseio. Implementa despache múltiplo.\n\ncopy_tree(node::AbstractNode)::TerminalNode\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.depth-Tuple{GP_NLS.TerminalNode}","page":"Funções de utilidade","title":"GP_NLS.depth","text":"Função que recebe um nó qualquer de uma árvore (AbstractNode) e recursivamente encontra a profundidade da árvore como sendo o tamanho de seu maior galho. Implementa múltiplo despache.\n\ndepth(node::AbstractNode)::Int64\n\nEssa profundidade corresponde ao número de nós existentes, sendo que os nós de variáveis ponderadas (que são uma subárvore com profundidade 2) ainda são considerados com profundidade 1.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}","page":"Funções de utilidade","title":"GP_NLS.get_branch_at","text":"Função que recebe um nó qualquer de uma árvore (AbstractNode) e um inteiro p (que deve ser menor ou igual ao número de nós da árvore passada) e retorna o galho na posição p.\n\nget_branch_at(p::Int64, node::AbstractNode)::AbstractNode\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}","page":"Funções de utilidade","title":"GP_NLS.get_depth_at","text":"Recebe um ponto p do tipo inteiro (que deve ser menor ou igual ao número de nós da árvore passada) e um nó qualquer representando uma árvoreAbstractNode, e encontra a profundidade da subárvore na posição p.\n\nget_depth_at(p::Int64, node::AbstractNode)::Int64\n\nÉ como o método de obter a profundidade, mas esse método calcula a profundidade parcial de uma subárvore que está no ponto p.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.getstring-Tuple{GP_NLS.TerminalNode}","page":"Funções de utilidade","title":"GP_NLS.getstring","text":"Função que recebe um nó qualquer de uma árvore (AbstractNode) e recursivamente constrói uma string representando a árvore passada. Funções são denotadas sempre na notação prefixada, com os argumentos entre parênteses.\n\ngetstring(node::AbstractNode)::String\n\nImplementa um despache múltiplo para cada subtipo de AbstractNode.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.numberofnodes-Tuple{GP_NLS.TerminalNode}","page":"Funções de utilidade","title":"GP_NLS.numberofnodes","text":"Função que recebe um nó qualquer de uma árvore (AbstractNode) e recursivamente conta o total de nós que a árvore possui. Implementa múltiplo despache.\n\nnumberofnodes(node::AbstractNode)::Int64\n\nEssa função não considera variáveis ponderadas como um único nó.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.true_depth-Tuple{GP_NLS.TerminalNode}","page":"Funções de utilidade","title":"GP_NLS.true_depth","text":"Função que recebe um nó qualquer de uma árvore (AbstractNode) e recursivamente encontra a profundidade da árvore como sendo o tamanho de seu maior galho. Implementa múltiplo despache.\n\ndepth(node::AbstractNode)::Int64\n\nEssa profundidade é real, e corresponde ao número de nós existentes, considerando a profundidade da subárvore de variáveis com pesos. Essa função não é utilizada nas implementações, e fica disponível para o usuário caso deseje obter a profundidade real considerando variáveis ponderadas. \n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.true_numberofnodes-Tuple{GP_NLS.TerminalNode}","page":"Funções de utilidade","title":"GP_NLS.true_numberofnodes","text":"Função que recebe um nó qualquer de uma árvore (AbstractNode) e recursivamente conta o total de nós que a árvore possui. Implementa múltiplo despache.\n\ntrue_numberofnodes(node::AbstractNode)::Int64\n\nEssa função não considera variáveis ponderadas como três nós. Essa função só é utilizada nas operações de mutação, crossover e inicialização para evitar árvores maiores que o  permitido.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}","page":"Funções de utilidade","title":"GP_NLS.which_children","text":"Função que recebe o conjunto de filhos children::Vector{AbstractNode} e um inteiro p (que deve ser menor ou igual ao número de nós somados de todos  os filhos passados) e encontra o filho que contém o p-ésimo nó da árvore caso fosse percorrida na ordem nó > filho 1 > filho 2 > .... p deve ser  obtida pelo número de nós da árvore (não o número de nós real, considerando vários nós em variáveis com peso).\n\nwhich_children(p::Int64, children::Vector{AbstractNode})::Tuple{Int64, AbstractNode}\n\nRetorna uma tupla contendo o filho que contém o nó de índice desejado, e um inteiro informando a posição do p-ésimo nó dentro da sub-árvore (filho) retornada.\n\n\n\n\n\n","category":"method"},{"location":"Utils/#Índice","page":"Funções de utilidade","title":"Índice","text":"","category":"section"},{"location":"Utils/","page":"Funções de utilidade","title":"Funções de utilidade","text":"","category":"page"}]
}
