<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utility functions · GP_NLS</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GP_NLS</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">GP_NLS</a></li><li><a class="tocitem" href="../Exported/">Types and functions exported</a></li><li><span class="tocitem">All source code</span><ul><li><a class="tocitem" href="../Nodes/">Node contents</a></li><li><a class="tocitem" href="../Trees/">Tree structures</a></li><li class="is-active"><a class="tocitem" href>Utility functions</a><ul class="internal"><li><a class="tocitem" href="#Tipos-e-Funções"><span>Tipos e Funções</span></a></li><li><a class="tocitem" href="#Índice"><span>Índice</span></a></li></ul></li><li><a class="tocitem" href="../Evaluation/">Tree evaluation</a></li><li><a class="tocitem" href="../Initialization/">Population initialization</a></li><li><a class="tocitem" href="../Evolutionary/">The GP Algorithm</a></li><li><a class="tocitem" href="../LsqOptimization/">Non-linear optimization</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">All source code</a></li><li class="is-active"><a href>Utility functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utility functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gAldeia/GP-NLS-julia" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Funções-de-utilidade"><a class="docs-heading-anchor" href="#Funções-de-utilidade">Funções de utilidade</a><a id="Funções-de-utilidade-1"></a><a class="docs-heading-anchor-permalink" href="#Funções-de-utilidade" title="Permalink"></a></h1><p>Implementação de algumas funções auxiliares que são utilizadas  para inspecionar e manipular as árvores de forma mais geral.</p><h2 id="Tipos-e-Funções"><a class="docs-heading-anchor" href="#Tipos-e-Funções">Tipos e Funções</a><a id="Tipos-e-Funções-1"></a><a class="docs-heading-anchor-permalink" href="#Tipos-e-Funções" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.branches_in_limits" href="#GP_NLS.branches_in_limits"><code>GP_NLS.branches_in_limits</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Finds all branches of any tree <code>node</code> that have a number of nodes less than or equal to <code>allowedSize</code> <strong>and</strong> a depth less than or equal to <code>allowedDepth</code> . Returns a list with the position of all branches found.</p><pre><code class="language-none">branches_in_limits(
    allowedSize::Int64, allowedDepth::Int64, node::AbstractNode, _point::Int64=1)::Vector{Int64}</code></pre><p>The <code>_point</code> parameter being returned is for internal use, and serves to monitor the point of the tree where the candidates were found. This is only meaningful to recursive calls, and outside of the function it does not represent any useful information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}" href="#GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}"><code>GP_NLS.change_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Takes a point <code>p</code> of type integer (<strong>which must be less than or equal to the number of nodes of <code>branch</code></strong>), a branch of type <code>AbstractNode</code>, and any node <code>AbstractNode</code> representing a tree. Returns a modification of the tree by inserting the branch into the tree at position `<span>$p$</span>. <strong>This function changes the tree passed as argument</strong>.</p><pre><code class="language-none">change_at!(p::Int64, branch::AbstractNode, node::AbstractNode)::AbstractNode</code></pre><p>This method is mainly used to modify trees in the <em>crossover</em> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}" href="#GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}"><code>GP_NLS.change_children!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes a point <code>p</code> (<strong>which must be less than or equal to the number of nodes of <code>branch</code></strong>), a branch of type <code>AbstractNode</code>, and a list of children <code>Vector{AbstractNode}</code>. Returns a modification of the list of children, where the <code>p</code> position node will be replaced by the given branch. <strong>This function changes the list of children passed as argument</strong>.</p><pre><code class="language-none">change_children!(p::Int64, branch::AbstractNode, children::Vector{AbstractNode})::Vector{AbstractNode}</code></pre><p>This function is a helper to <code>change_at!</code>, and itsfor internal use. It is not exported by the module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}" href="#GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.copy_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and recursively recreates the structure so that references are not shared between the tree passed and the tree returned, avoiding side effects when manipulating the tree.</p><pre><code class="language-none">copy_tree(node::AbstractNode)::TerminalNode</code></pre><p>This function works by having a multiple dispatch for each subtype of <code>AbstractNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.depth-Tuple{GP_NLS.TerminalNode}" href="#GP_NLS.depth-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.depth</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and recursively finds the depth of the tree, where the depth is the size of its largest branch. This depth function does not take into count the coefficients of weighted variables (which are, in fact, a subtree with depth 2). To find the depth of a tree considering weighted variables as a subtree (and not as a single node), use the function <code>true_depth</code>.</p><pre><code class="language-none">depth(node::AbstractNode)::Int64</code></pre><p>This function works by having a multiple dispatch for each subtype of <code>AbstractNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}" href="#GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}"><code>GP_NLS.get_branch_at</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and an integer <code>p</code> (<strong>which must be less than or equal to the number of nodes in <code>tree</code></strong>) and returns the branch at position <code>p</code>.</p><pre><code class="language-none">get_branch_at(p::Int64, node::AbstractNode)::AbstractNode</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}" href="#GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}"><code>GP_NLS.get_depth_at</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Takes a point <code>p</code> of type integer (<strong>which must be less than or equal to the number of nodes of the <code>node</code> passed</strong>) and any node <code>AbstractNode</code> representing a tree, then this function find and return the depth of the subtree at position <code>p</code>.</p><pre><code class="language-none">get_depth_at(p::Int64, node::AbstractNode)::Int64</code></pre><p>It&#39;s almost like finding the depth of the tree, but when we are interested  in finding the depth of a subtree that is at the point <code>p</code>, not the whole tree depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.getstring-Tuple{GP_NLS.TerminalNode}" href="#GP_NLS.getstring-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.getstring</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and recursively builds a <em>string</em> representation of the tree, where functions are always denoted in prefixed notation, with arguments in parentheses.</p><pre><code class="language-none">getstring(node::AbstractNode)::String</code></pre><p>This function works by having a multiple dispatch for each subtype of <code>AbstractNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.numberofnodes-Tuple{GP_NLS.TerminalNode}" href="#GP_NLS.numberofnodes-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.numberofnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and recursively counts the total number of nodes of the tree. This function counts weighted variables as a single node. To find the number of nodes of a tree considering weighted variables as a subtree (and not as a single node), use the function <code>true_numberofnodes</code>.</p><pre><code class="language-none">numberofnodes(node::AbstractNode)::Int64</code></pre><p>This function works by having a multiple dispatch for each subtype of <code>AbstractNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.true_depth-Tuple{GP_NLS.TerminalNode}" href="#GP_NLS.true_depth-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.true_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and recursively finds the depth of the tree, where the depth is the size of its largest branch. This depth function returns a value that corresponds to the number of existing nodes in the tree, considering weighted variables as being a subtree of depth 2. This function is not used in implementations, and is available to users who want to get the real depth of GP-NLS trees.</p><pre><code class="language-none">true_depth(node::AbstractNode)::Int64</code></pre><p>This function works by having a multiple dispatch for each subtype of <code>AbstractNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.true_numberofnodes-Tuple{GP_NLS.TerminalNode}" href="#GP_NLS.true_numberofnodes-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.true_numberofnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes any node of a tree (<code>AbstractNode</code>) and recursively counts the total number of nodes of the tree. This function counts weighted  variables as three nodes. This function is only used in mutate, crossover, and initialize operations to avoid creating trees larger than the allowed.</p><pre><code class="language-none">true_numberofnodes(node::AbstractNode)::Int64</code></pre><p>This function works by having a multiple dispatch for each subtype of <code>AbstractNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}" href="#GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}"><code>GP_NLS.which_children</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function that takes a set of children of the same node as the array <code>children::Vector{AbstractNode}</code>, and an integer <code>p</code> (<strong>which must be less than or equal to number of nodes in <code>children</code></strong>) and finds the child containing the p-th node of the children if it was traversed inorder.</p><p>Returns a tuple containing the child which contains the node of index <code>p</code>, and an integer informing the position of the p-th node within the returned (child) subtree.</p><pre><code class="language-none">which_children(p::Int64, children::Vector{AbstractNode})::Tuple{Int64, AbstractNode}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gAldeia/GP-NLS-julia">source</a></section></article><h2 id="Índice"><a class="docs-heading-anchor" href="#Índice">Índice</a><a id="Índice-1"></a><a class="docs-heading-anchor-permalink" href="#Índice" title="Permalink"></a></h2><ul><li><a href="../Nodes/#GP_NLS.defaultConstSet"><code>GP_NLS.defaultConstSet</code></a></li><li><a href="../Nodes/#GP_NLS.defaultERCSet"><code>GP_NLS.defaultERCSet</code></a></li><li><a href="../Nodes/#GP_NLS.defaultFunctionSet"><code>GP_NLS.defaultFunctionSet</code></a></li><li><a href="../Trees/#GP_NLS.AbstractNode"><code>GP_NLS.AbstractNode</code></a></li><li><a href="../Nodes/#GP_NLS.Const"><code>GP_NLS.Const</code></a></li><li><a href="../Nodes/#GP_NLS.ERC"><code>GP_NLS.ERC</code></a></li><li><a href="../Nodes/#GP_NLS.Func"><code>GP_NLS.Func</code></a></li><li><a href="../Trees/#GP_NLS.InternalNode"><code>GP_NLS.InternalNode</code></a></li><li><a href="../Trees/#GP_NLS.TerminalNode"><code>GP_NLS.TerminalNode</code></a></li><li><a href="../Nodes/#GP_NLS.Var"><code>GP_NLS.Var</code></a></li><li><a href="../Nodes/#GP_NLS.WeightedVar"><code>GP_NLS.WeightedVar</code></a></li><li><a href="../Evolutionary/#GP_NLS.GP"><code>GP_NLS.GP</code></a></li><li><a href="../Initialization/#GP_NLS.PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64}"><code>GP_NLS.PTC2</code></a></li><li><a href="../Initialization/#GP_NLS._create_random_terminal-Tuple{Array{Union{ERC, Const, Var, WeightedVar},1}}"><code>GP_NLS._create_random_terminal</code></a></li><li><a href="#GP_NLS.branches_in_limits"><code>GP_NLS.branches_in_limits</code></a></li><li><a href="#GP_NLS.change_at!-Tuple{Int64,GP_NLS.AbstractNode,GP_NLS.AbstractNode}"><code>GP_NLS.change_at!</code></a></li><li><a href="#GP_NLS.change_children!-Tuple{Int64,GP_NLS.AbstractNode,Array{GP_NLS.AbstractNode,1}}"><code>GP_NLS.change_children!</code></a></li><li><a href="#GP_NLS.copy_tree-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.copy_tree</code></a></li><li><a href="../Evolutionary/#GP_NLS.crossover-Tuple{GP_NLS.AbstractNode,GP_NLS.AbstractNode,Int64,Int64}"><code>GP_NLS.crossover</code></a></li><li><a href="#GP_NLS.depth-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.depth</code></a></li><li><a href="../Evaluation/#GP_NLS.evaluate-Tuple{GP_NLS.TerminalNode,Array{Float64,2}}"><code>GP_NLS.evaluate</code></a></li><li><a href="../Evaluation/#GP_NLS.fitness-Tuple{GP_NLS.AbstractNode,Array{Float64,2},Array{Float64,1}}"><code>GP_NLS.fitness</code></a></li><li><a href="../Initialization/#GP_NLS.full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}"><code>GP_NLS.full</code></a></li><li><a href="#GP_NLS.get_branch_at-Tuple{Int64,GP_NLS.AbstractNode}"><code>GP_NLS.get_branch_at</code></a></li><li><a href="#GP_NLS.get_depth_at-Tuple{Int64,GP_NLS.AbstractNode}"><code>GP_NLS.get_depth_at</code></a></li><li><a href="#GP_NLS.getstring-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.getstring</code></a></li><li><a href="../Initialization/#GP_NLS.grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64}"><code>GP_NLS.grow</code></a></li><li><a href="../Initialization/#GP_NLS.init_pop_PTC2-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}"><code>GP_NLS.init_pop_PTC2</code></a></li><li><a href="../Initialization/#GP_NLS.init_pop_full-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}"><code>GP_NLS.init_pop_full</code></a></li><li><a href="../Initialization/#GP_NLS.init_pop_grow-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}"><code>GP_NLS.init_pop_grow</code></a></li><li><a href="../Initialization/#GP_NLS.init_pop_ramped-Tuple{Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Int64,Int64,Int64,Int64}"><code>GP_NLS.init_pop_ramped</code></a></li><li><a href="../Evolutionary/#GP_NLS.mutation!-Tuple{GP_NLS.AbstractNode,Int64,Int64,Array{Func,1},Array{Union{ERC, Const, Var, WeightedVar},1},Float64}"><code>GP_NLS.mutation!</code></a></li><li><a href="#GP_NLS.numberofnodes-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.numberofnodes</code></a></li><li><a href="../Evolutionary/#GP_NLS.tourn_selection-Tuple{Tuple{GP_NLS.AbstractNode,Float64},Tuple{GP_NLS.AbstractNode,Float64}}"><code>GP_NLS.tourn_selection</code></a></li><li><a href="#GP_NLS.true_depth-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.true_depth</code></a></li><li><a href="#GP_NLS.true_numberofnodes-Tuple{GP_NLS.TerminalNode}"><code>GP_NLS.true_numberofnodes</code></a></li><li><a href="#GP_NLS.which_children-Tuple{Int64,Array{GP_NLS.AbstractNode,1}}"><code>GP_NLS.which_children</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Trees/">« Tree structures</a><a class="docs-footer-nextpage" href="../Evaluation/">Tree evaluation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 13 November 2021 20:02">Saturday 13 November 2021</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
